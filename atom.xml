<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>打球只投三分</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cherryyang05.github.io/"/>
  <updated>2020-05-26T15:05:44.681Z</updated>
  <id>http://cherryyang05.github.io/</id>
  
  <author>
    <name>Cherry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux服务器配置</title>
    <link href="http://cherryyang05.github.io/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://cherryyang05.github.io/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-05-26T14:10:55.000Z</published>
    <updated>2020-05-26T15:05:44.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验内容介绍"><a href="#实验内容介绍" class="headerlink" title="实验内容介绍"></a>实验内容介绍</h3><p>Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 <code>WAMP(Windows+Apache+MySQL+PHP)</code> 和 <code>LAMP(Linux+Apache+MySQL+PHP)</code>架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本实验中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。<br>Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。<br>本实验演示以 kali 64 位操作系统为例。因 kali 系统已经自带 Apache、MySQL 和 PHP，为了解安装流程，请先卸载系统自带软件。</p><a id="more"></a><h3 id="卸载系统原有Apache、MySQL、PHP"><a href="#卸载系统原有Apache、MySQL、PHP" class="headerlink" title="卸载系统原有Apache、MySQL、PHP"></a>卸载系统原有Apache、MySQL、PHP</h3><p>sudo apt-get remove apache2<br>sudo apt-get remove mysql-*<br>sudo apt-get remove php</p><h3 id="在线安装Apache-服务器"><a href="#在线安装Apache-服务器" class="headerlink" title="在线安装Apache 服务器"></a>在线安装Apache 服务器</h3><p>输入命令：<code>sudo apt-get install apache2</code></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/在线安装Apache服务器.png" alt="在线安装Apache服务器"></p><p>输入命令：<code>sudo /etc/init.d/apache2 start</code> 手动启动服务</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/启动Apache服务.png" alt="启动Apache服务"></p><p>以上页面详细介绍了 Debian 发行版 Linux 中 Apache 基本信息，其中：</p><p><strong>Apache 根目录：</strong><br><code>/var/www/html</code></p><p><strong>Apache 配置目录和文件：</strong><br><code>/etc/apache2</code>: Apache 主配置目录， Apache 所有配置文件均在此目录下；<br><code>/etc/apache2/apache2.conf</code>: 主配置文件，可配置 Apache 全局配置；<br><code>/etc/apache2/ports.conf</code>: 端口配置文件。默认情况下，当启用提供 SSL功能的模块时，Apache 监听端口 80，并在端口 443 上进行监听。<br>其它文件略。</p><p><strong>Apache 日志文件：</strong><br><code>/var/log/apache2/access.log</code>: 服务请求日志<br><code>/var/log/apache2/error.log</code>: 服务错误日志</p><p><strong>Apache 基本操作：</strong><br>服务启动：<code>/etc/init.d/apache2 start</code><br>服务停止：<code>/etc/init.d/apache2 stop</code><br>服务重启：<code>/etc/init.d/apache2 restart</code><br>部分 Linux 安装 Apache 后可能出现服务正常运行，相应端口正常打开，但其它主机无法访问情况，此现象一般是因为系统防火墙未开放相应服务端口。在浏览器找那个输入虚拟机的IP，看到：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/Apache服务启动成功.png" alt="Apache服务启动成功"></p><p>说明服务器配置成功！</p><h3 id="安装-MySQL-MariaDB"><a href="#安装-MySQL-MariaDB" class="headerlink" title="安装 MySQL/MariaDB"></a>安装 MySQL/MariaDB</h3><p>本示例采用 MariaDB 代替 MySQL。MariaDB 是 MySQL 的一个分支，现由开源社区维护，采用 GPL 授权许可，其大部分语法与 MySQL 都相同。因 MySQL 被 Oracle收购后有闭源的风险，大部分 Linux 组织均从其套件清单删除了 MySQL，并以MariaDB 代替 MySQL，若一定要使用 MySQL，可通过下载安装包的方式手动安装MySQL。</p><p>安装 MariaDB 服务：<br><code>sudo apt-get install mariadb-server</code><br><code>sudo apt-get install mariadb-client</code></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/安装mariadb.png" alt="安装mariadb"></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/安装mariadb2.png" alt="安装mariadb2"></p><h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><h5 id="首先就是提示没有mariadb-server软件包，类似于这样"><a href="#首先就是提示没有mariadb-server软件包，类似于这样" class="headerlink" title="首先就是提示没有mariadb-server软件包，类似于这样"></a>首先就是提示没有<code>mariadb-server</code>软件包，类似于这样</h5><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/提示没有mariadb软件包.png" alt="提示没有mariadb软件包"></p><p>这个可能是apt版本不够，需要执行<code>sudo apt-get update</code> 进行更新，但是更新实在太慢，我更新了33分钟才更新好，这时候已经快下课了。</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/apt-get-update.png" alt="apt-get-update"></p><h5 id="然后就是出现域名无法解析的错误"><a href="#然后就是出现域名无法解析的错误" class="headerlink" title="然后就是出现域名无法解析的错误"></a>然后就是出现域名无法解析的错误</h5><p>这个错误困扰了我好久，按照网上的方法试了很多，但是还是不行。最后发现是<code>/etc/network/interfaces</code>文件中网关写错了，写成了<code>192.168.1.0</code>，正确的应该是<code>192.168.1.1</code><br>然后修改<code>/etc/resolv.conf</code>文件，增加字段：<code>nameserver 8.8.8.8（好像是谷歌的DNS服务器）</code>，然后执行<code>ifdown -a</code>关闭网卡，<code>ifup -a</code>启动网卡，然后就可以了。</p><p>至于为什么会出现DNS解析错误，一开始我的虚拟机的网络是用的NAT（虚拟地址转换），在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。在NAT模式下，宿主计算机相当于一台开启了DHCP功能的路由器，而虚拟机则是内网中的一台真实主机，通过路由器(宿主计算机)DHCP动态获得网络参数。因此在NAT模式下，虚拟机可以访问外部网络，反之则不行，因为虚拟机属于内网。</p><p>而改成了桥接模式后，虚拟机和宿主计算机处于同等地位（同处一个局域网），虚拟机就像是一台真实主机一样存在于局域网中。因此在桥接模式下，我们就要像对待其他真实计算机一样为其配置IP、网关、子网掩码等等。<br>但是修改<code>/etc/resolv.conf</code>，重启过后就没有了，我们需要安装<code>resolvconfig</code>应用组件：<code>sudo apt-get install resolvconf</code>，在<code>/etc/resolvconf/resolv.conf.d/base</code>文件中添加DNS信息<code>（nameserver 8.8.8.8）</code>，就可以了。</p><p>然后再次重新启动，刚刚的问题解决！</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/resolvconfig应用.png" alt="resolvconfig应用"></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/apt-get更新成功.png" alt="apt-get更新成功"></p><p><strong>配置 Mariadb 的安全选项:</strong><br><code>sudo mysql_secure_installation</code></p><p>此时系统会提示输入数据库 root 用户密码，因系统并未设置相应密码，此时直接按提示回车即可。若提示错误，则 sudo /etc/init.d/mysql restart 命令重启 mysql 服务并重新执行安全选项命令。随后数据库会提示以下安全设置信息，一般设置数据库 root 用户密码即可，其它选项按回车选择默认：</p><ol><li>Enter current password for root (enter for none): 输入当前 root的密码(因新数据库无密码，回车即可)；</li><li>Set root password? [Y/n] 回车，默认为输入 Y；</li><li>New password: 输入新密码；</li><li>Re-enter new password 确认密码；</li><li>Remove anonymous users? [Y/n] 移除匿名用户；</li><li>Disallow root login remotely? [Y/n] 禁止 root 远程登录；</li><li>Remove test database and access to it? [Y/n] 移除测试数据库；</li><li>Reload privilege tables now? [Y/n] 重新加载权限表。</li></ol><p><strong>测试数据库:</strong><br>如图所示，若进入数据库则表示数据库安装成功，sudo mysql -u root -p</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/MySQL.png" alt="MySQL"></p><h3 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h3><p>安装 PHP 除了 PHP 应用程序外，还需安装 PHP 与 Apache、MySQL/MariaDB相关扩展包，扩展包需与软件对应，本例中安装 php7.2 版本，对应扩展包可通过以下命令模糊查询：<br><code>sudo apt-cache search php7</code><br>从查询结果可知，php7.3对应Apache、MySQL扩展包分别为 ：<code>libapahe2-mod-php7.2，php7.2-mysql</code>.如下图所示为安装 PHP 相关软件包。<br><code>sudo apt-get install php7.2 libapahe2-mod-php7.2 php7.2-mysqlPHP</code> 安装完毕后需重启 Apache</p><h3 id="测试PHP页面"><a href="#测试PHP页面" class="headerlink" title="测试PHP页面"></a>测试PHP页面</h3><p>编辑测试文件，如下图所示，在 <code>/var/www/html</code> 目录下新建 <code>test.php</code> 文件，并输入如下所示的测试代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中访问如下：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/安装PHP.png" alt="安装PHP"></p><p><strong>注意：我修改了Apache的端口为8080，因此访问时要在URL后面加上8080端口。</strong></p><h3 id="创建文件上传页面"><a href="#创建文件上传页面" class="headerlink" title="创建文件上传页面"></a>创建文件上传页面</h3><p>文件上传功能由上传文件的 HTML 表单和文件上传脚本构成。在根目录下创建<code>upload.html</code>文件，编辑表单</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/upload.html.png" alt="upload.html"></p><p>在根目录下创建 <code>upload.php</code> 脚本文件，编写文件上传功能代码：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/upload.php.png" alt="upload.php"></p><p>在根目录下创建“upload”目录，用于保存上传的图片<br>然后访问<code>192.168.1.120:8080/upload.html</code></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/访问html.png" alt="访问html"></p><p>选择一个不超过200K的图片文件：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/链接php.png" alt="链接php"></p><p>先修改upload文件夹的权限，上传之后查看服务器中upload文件夹：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/upload文件夹.png" alt="upload文件夹"></p><p>或者查看Apache的属主：<code>ps -ef | grep apache</code>，发现是<code>www-data</code></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/Apache属主.png" alt="Apache属主"></p><p>然后更改修改目录的所有者：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/chown更改属主.png" alt="chown更改属主"></p><p>结果和上述一样，大功告成！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实验内容介绍&quot;&gt;&lt;a href=&quot;#实验内容介绍&quot; class=&quot;headerlink&quot; title=&quot;实验内容介绍&quot;&gt;&lt;/a&gt;实验内容介绍&lt;/h3&gt;&lt;p&gt;Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 &lt;code&gt;WAMP(Windows+Apache+MySQL+PHP)&lt;/code&gt; 和 &lt;code&gt;LAMP(Linux+Apache+MySQL+PHP)&lt;/code&gt;架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本实验中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。&lt;br&gt;Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。&lt;br&gt;本实验演示以 kali 64 位操作系统为例。因 kali 系统已经自带 Apache、MySQL 和 PHP，为了解安装流程，请先卸载系统自带软件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux实验" scheme="http://CherryYang05.github.io/categories/Linux%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="Linux服务器" scheme="http://CherryYang05.github.io/tags/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机知识总结（二）</title>
    <link href="http://cherryyang05.github.io/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://cherryyang05.github.io/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-05-24T09:28:44.000Z</published>
    <updated>2020-05-24T09:45:08.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三、GC算法和收集器"><a href="#三、GC算法和收集器" class="headerlink" title="三、GC算法和收集器"></a>三、GC算法和收集器</h2><p>本文参考：<br>Oracle Java JVM Standard Options：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a><br>HotSpot Glossary of Terms：<a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a><br>周志明《深入理解Java虚拟机》第二版</p><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0的对象就是不可能再被使用的。<br>这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决对象之前相互循环引用的问题。所谓对象之间的相互引用问题，通过下面代码所示：除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三、GC算法和收集器&quot;&gt;&lt;a href=&quot;#三、GC算法和收集器&quot; class=&quot;headerlink&quot; title=&quot;三、GC算法和收集器&quot;&gt;&lt;/a&gt;三、GC算法和收集器&lt;/h2&gt;&lt;p&gt;本文参考：&lt;br&gt;Oracle Java JVM Standard Opti
      
    
    </summary>
    
    
      <category term="Java虚拟机" scheme="http://CherryYang05.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://CherryYang05.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机知识总结(一)</title>
    <link href="http://cherryyang05.github.io/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://cherryyang05.github.io/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-05-24T06:42:02.000Z</published>
    <updated>2020-05-24T09:51:17.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java虚拟机介绍"><a href="#Java虚拟机介绍" class="headerlink" title="Java虚拟机介绍"></a>Java虚拟机介绍</h2><p>Java虚拟机(Java Virtual Machine，JVM)，一种能够运行Java字节码的虚拟机。作为一种编程语言的虚拟机，实际上<br>不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。<br><a id="more"></a></p><h2 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h2><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/JVM基本结构.png" alt="JVM基本结构"></p><p>JVM由三个主要的子系统构成</p><ul><li>类加载子系统</li><li>运行时数据区（内存结构）</li><li>执行引擎</li></ul><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/类加载机制.png" alt="类的生命周期"></p><ol><li>加载<br>将<code>.class</code>文件从磁盘读到内存</li><li>链接<ol><li>验证<br>验证字节码文件的正确性</li><li>准备<br>给类的静态变量分配内存</li><li>解析<br>类加载器装入类所引用的其他所有类(静态链接)<br>静态链接：解析阶段，由符号引用转化为直接引用<br>动态链接：程序运行期间，由符号引用转化为直接引用</li></ol></li><li>初始化<br>为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序<br>编写者为变量分配的真正的初始值，执行静态代码块</li><li>使用</li><li>卸载</li></ol><h3 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h3><ul><li>启动类加载器(Bootstrap ClassLoader)<br>负责加载JRE的核心类库，如JRE目标下的<code>rt.jar</code>,<code>charsets.jar</code>等</li><li>扩展类加载器(Extension ClassLoader)<br>负责加载JRE扩展目录<code>ext</code>中jar类包</li><li>系统类加载器(Application ClassLoader)<br>负责加载<code>ClassPath</code>路径下的类包</li><li>用户自定义加载器(User ClassLoader)<br>负责加载用户自定义路径下的类包</li></ul><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/加载器.png" alt="加载器"></p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><h4 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h4><p>当一个<code>ClassLoader</code>加载一个类的时候，除非显式的使用另一个<code>ClassLoader</code>,该类所依赖和引用的类也由这个<code>ClassLoader</code>载入</p><h4 id="双亲委派机制-1"><a href="#双亲委派机制-1" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>指先委托父类加载器寻找目标类，在找不到的情况下载自己的路径中查找并载入目标类。实际上<code>双亲委派机制</code>实则<code>父类委派机制</code>。</p><h5 id="双亲委派模式的优势"><a href="#双亲委派模式的优势" class="headerlink" title="双亲委派模式的优势"></a>双亲委派模式的优势</h5><ul><li>沙箱安全机制：比如自己写的<code>String.class</code>类不会被加载，这样可以防止核心库被随意篡改</li><li>避免类的重复加载：当父<code>ClassLoader</code>已经加载了该类的时候，就不需要子<code>ClassLoader</code>再加载一次</li></ul><p><em>要确定一个类的唯一性，要获得该类的类加载器实例以及类的全限定名。</em></p><p>不同的类加载器加载同一个<code>class</code>文件是不同的类模板信息</p><p>为什么要打破双亲委派机制？<br>Tomcat为了做wap包隔离</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/运行时数据区.png" alt="运行时数据区"></p><p>堆：用来放类的实例对象<br>栈：栈帧，用来存放方法，线程</p><h4 id="方法区（Method-Area）-永久代-持久代jdk1-8以前，元空间"><a href="#方法区（Method-Area）-永久代-持久代jdk1-8以前，元空间" class="headerlink" title="方法区（Method Area）(永久代/持久代jdk1.8以前，元空间)"></a>方法区（Method Area）(永久代/持久代jdk1.8以前，元空间)</h4><p>类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)</p><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><ul><li>YoungGC/MinorGC</li><li>CMS OldGC</li><li>MajorGC/FullGC</li></ul><p>虚拟机启动时自动分配创建，用于存放对象的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内存是将抛出<code>OutOfMemoryError(OOM)</code>异常。同时也是垃圾收集器管理的主要区域。</p><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/堆.png" alt="堆"></p><p>当年龄到15时，转入老年代</p><h5 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h5><p>类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。<br>新生代分为两部分：伊甸区<code>（Eden space）</code>和幸存者区<code>（Survivor space）</code>，所有的类都是在伊甸区被new出来的。<br>幸存区又分为<code>From</code>和<code>To</code>区。当<code>Eden</code>区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将<code>Eden</code>区进行垃圾回<br>收<code>（Minor GC）</code>，将<code>Eden</code>区中的不再被其它对象应用的对象进行销毁。然后将<code>Eden</code>区中剩余的对象移到<code>From Survivor</code>区。若<code>From Survivor</code>区也满了，再对该区进行垃圾回收，然后移动到<code>To Survivor</code>区。</p><h5 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h5><p>新生代经过多次GC仍然存货的对象移动到老年区。若老年代也满了，这时候将发生<code>Major GC</code>（也可以叫<code>Full GC</code>），进行老年区的内存清理。若老年区执行了<code>Full GC</code>之后发现依然无法进行对象的保存，就会抛出<code>OOM（OutOfMemoryError）</code>异常</p><h5 id="元空间（Meta-Space）"><a href="#元空间（Meta-Space）" class="headerlink" title="元空间（Meta Space）"></a>元空间（Meta Space）</h5><p>在<code>JDK1.8</code>之后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。</p><p><strong>为什么移除了永久代？</strong><br>参考官方解释 <strong><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a></strong></p><p>大概意思是移除永久代是为融合<code>HotSpot</code>与<code>JRockit</code>而做出的努力，因为<code>JRockit</code>没有永久代，不需要配置永久代。</p><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/堆和GC.png" alt="新生代和老年代转化"></p><h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h4><p>Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致.</p><h4 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h4><p>和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记<code>native</code>方法，在<code>Execution Engine</code>执行时加载本地方法库</p><h4 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h4><p>就是一个指针，指向方法区中的方法字节码（用来存储指向下一跳指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计</p><hr><h6 id="将下面代码编译生成Class字节码并反汇编："><a href="#将下面代码编译生成Class字节码并反汇编：" class="headerlink" title="将下面代码编译生成Class字节码并反汇编："></a>将下面代码编译生成<code>Class</code>字节码并反汇编：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      JVM jvm = <span class="keyword">new</span> JVM();</span><br><span class="line">      System.out.println(jvm.math());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编后：<code>(javap -c JVM.class &gt; JVM.txt)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JVM.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JVM</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_5</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      11: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">14</span>: iload_1</span><br><span class="line">      15: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">18</span>: iload_3</span><br><span class="line">      <span class="number">19</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #4                  // class JVM</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #5                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      12: invokevirtual #6                  // Method math:()I</span><br><span class="line">      15: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多其实都是编译原理的知识，下面是数据区：</p><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/数据区.png" alt="数据区"></p><p>反汇编之后前面的数字序号便是程序计数器<code>PC</code></p><p>目前市面上大部分虚拟机都是用<code>C/C++</code>实现的，实际上最后启动线程都是通过<code>C/C++</code>库来调用操作系统内核函数实现。</p><p>利用<code>javap -v JVM.class &lt; dynamicLink.txt</code>查看动态链接详细信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">Classfile /G:/JVM<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-5-24</span>; size <span class="number">493</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">5</span>cdaa7b4d5fb74c45c86c10186ae5c8c</span><br><span class="line">  Compiled from <span class="string">"JVM.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#18         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #19.#20        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #21.#22        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #23            // JVM</span><br><span class="line">   #5 = Methodref          #4.#18         // JVM."&lt;init&gt;":()V</span><br><span class="line">   #6 = Methodref          #4.#24         // JVM.math:()I</span><br><span class="line">   #7 = Class              #25            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               math</span><br><span class="line">  #13 = Utf8               ()I</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               SourceFile</span><br><span class="line">  #17 = Utf8               JVM.java</span><br><span class="line">  #18 = NameAndType        #8:#9          // "&lt;init&gt;":()V</span><br><span class="line">  #19 = Class              #26            // java/lang/System</span><br><span class="line">  #20 = NameAndType        #27:#28        // out:Ljava/io/PrintStream;</span><br><span class="line">  #21 = Class              #29            // java/io/PrintStream</span><br><span class="line">  #22 = NameAndType        #30:#31        // println:(I)V</span><br><span class="line">  #23 = Utf8               JVM</span><br><span class="line">  #24 = NameAndType        #12:#13        // math:()I</span><br><span class="line">  #25 = Utf8               java/lang/Object</span><br><span class="line">  #26 = Utf8               java/lang/System</span><br><span class="line">  #27 = Utf8               out</span><br><span class="line">  #28 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #29 = Utf8               java/io/PrintStream</span><br><span class="line">  #30 = Utf8               println</span><br><span class="line">  #31 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JVM</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iconst_5</span><br><span class="line">         <span class="number">3</span>: istore_2</span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">9</span>: imul</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        11: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">14</span>: iload_1</span><br><span class="line">        15: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #4                  // class JVM</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #5                  // Method "&lt;init&gt;":()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">11</span>: aload_1</span><br><span class="line">        12: invokevirtual #6                  // Method math:()I</span><br><span class="line">        15: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"JVM.java"</span></span><br></pre></td></tr></table></figure><p>第一段的<code>Constant pool</code>是符号引用</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java虚拟机介绍&quot;&gt;&lt;a href=&quot;#Java虚拟机介绍&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机介绍&quot;&gt;&lt;/a&gt;Java虚拟机介绍&lt;/h2&gt;&lt;p&gt;Java虚拟机(Java Virtual Machine，JVM)，一种能够运行Java字节码的虚拟机。作为一种编程语言的虚拟机，实际上&lt;br&gt;不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java虚拟机" scheme="http://CherryYang05.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://CherryYang05.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>DHCP主机动态配置协议详解以及代码实现</title>
    <link href="http://cherryyang05.github.io/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://cherryyang05.github.io/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-05-15T10:20:18.000Z</published>
    <updated>2020-05-20T15:39:32.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、DHCP介绍"><a href="#一、DHCP介绍" class="headerlink" title="一、DHCP介绍"></a>一、DHCP介绍</h2><h3 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1. 简要介绍"></a>1. 简要介绍</h3><p>DHCP协议在我们日常生活中应该是最常见而又经常被忽略的一种协议了。当你走进一间屋子，手机自动连上了WiFi，当你离开了屋子，又自动断开了WiFi……这一系列的幕后都是DHCP协议在默默工作。</p><p>DHCP协议(Dynamic Host Configuration Protocol)是一个基于UDP协议的局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p><p>该协议的做大作用是动态的为加入网络的设备分配IP地址，在该协议出现前，IP地址的分配基于静态模式，你把设备的mac地址手动在路由器设置，然后路由器自动生成一个IP与你的mac地址绑定起来。这种应用在有线网络时代可以适用，但在无线时代，每时每刻可能有不同的设备加入或离开网络，因此原有静态匹配IP的做法不再适合。</p><p>DHCP协议的诞生就是为了迎合在无线情况下，网络内部连接设备不断变化的情况。它包含两部分，一是分配IP地址，二是支持客户端请求，服务器应答，使得两者之间有效交换配置信息。</p><p>DHCP最重要功能显然是动态分配IP地址，当我们的设备连接上网络之后里面获得一个可用的IP地址，就得感谢该协议的执行，现在我们大多数设备都依靠DHCP来从路由器动态获得IP<br><a id="more"></a></p><h3 id="2-DHCP的IP租借"><a href="#2-DHCP的IP租借" class="headerlink" title="2. DHCP的IP租借"></a>2. DHCP的IP租借</h3><p>DHCP协议能够维护一个动态的IP池，根据设备加入和离开网络回收或分发可用IP，它甚至能实现多个设备共享相同IP。DHCP协议的实现基于UDP，需要IP的设备和具备分配IP能力的设备根据DHCP协议的方式封装数据包，然后通过UDP协议发送给对方。有了该协议后，我们上网时不再麻烦的去配置各种信息，设备和路由器之间相互通信后，自动配置好相应信息，我们只要等着配置完毕然后上网就行。</p><p>DHCP支持三种地址分配方式，一种是手动分配，由管理员手动将指定IP地址分发给特定设备；第二种是自动分配，它从当前可用的IP地址池中选出一个，永久的分发给某一台特定设备；第三种是动态分配，它从IP地址池中选出一个分发给某台设备一段时间，时间到了后收回，或者设备离开网络后通知路由器主动收回，由此可见，第二种和第三种区别不大</p><p>使用动态分配方式时，管理员指定一系列可以分配的IP，然后DHCP服务器会自动维护哪些IP已经分配，哪些IP可以使用。同时服务器指定分配的IP使用时长，一旦超时后，客户必须主动向服务器请求续租，例如上图就有对应按钮，或者请求重新从服务器获得一个新的IP地址，这个请求应答过程将是我们研究和实现的重点。</p><p>DHCP协议动态分配IP的好处显而易见，首先是自动化，省却了管理员耗时耗力的维护，其次是集中管理，从服务器就可以得知IP的使用情况，由此有效防止IP冲突。而且还能实现地址的共享和重用，如果一台设备不活跃，例如关机或离开网络，协议可以及时收回IP，分发给在网络中的其他设备。</p><p>在DHCP协议管理下，所有设备只能”租借“IP而不能“拥有”IP。有租借就必须有管理，DHCP协议的主要内容就在这里。租借时常根据设备的使用情况而定，作为服务器的设备租借时间必须很长，而对于手持设备而言，租借时间可以很短。在很多情况下，管理员为了防止IP被长时间无效占用，例如某台设备计划租借一个月，但它运行一天就关机了，那么这个IP就会在余下29天浪费掉，因此管理员会强制设备租借短时期，时期到了后再跟服务器请求延长租借期。</p><p>管理员一般把IP池划分为若干类别，不同类别对应不同租期，然后根据接入设备的类型赋予不同类别的IP。一旦租期抵达一半时，设备就开始于服务器协商以便延长租期。</p><p>下面是IP租借的流程图：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP租借.png" alt="IP租借"></p><p>上图描述了设备向DHCP服务器租借IP8天流程，其中在第4天要与服务器协商续租。租借IP的设备需要保持两个时钟，时钟T1在租借期过了一半时触发，此时设备向服务器请求续租；如果续租不成功，第二个时钟在租期87.5%时触发，设备向另一个DHCP服务器发起租借IP的请求。我们后面用代码实现协议时，主要通过构造数据包完成上面所述流程。</p><p>DHCP协议时典型的服务器客户端应用模式。需要IP的设备是客户端，分发IP的设备是服务器，两者通过互发消息完成一项任务。他们之间的交互可以由下图表达：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP握手.jpg" alt="DHCP握手"></p><p>类似于<code>TCP</code>的握手，但是又比TCP简单不少。</p><h2 id="二、DHCP主机动态配置协议解析和数据包格式说明"><a href="#二、DHCP主机动态配置协议解析和数据包格式说明" class="headerlink" title="二、DHCP主机动态配置协议解析和数据包格式说明"></a>二、DHCP主机动态配置协议解析和数据包格式说明</h2><h3 id="1-查看DHCP数据包"><a href="#1-查看DHCP数据包" class="headerlink" title="1. 查看DHCP数据包"></a>1. 查看DHCP数据包</h3><p>打开网络封包分析软件WireShack，输入过滤条件<code>bootp.option.type == 53</code>(或者<code>dhcp.option.type == 53</code>也可)，在命令行中输入<code>ipconfig/renew</code>，表示续租DHCP服务器，我们获取这样的数据包：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP数据包介绍.png" alt="DHCP数据包介绍"></p><p>点开一个数据包，看到：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/具体格式.png" alt="具体格式"></p><p>我们看到DHCP协议数据包的组成格式为<code>IP数据包-&gt;UDP数据包-&gt;Boostrap Protocoal数据包(也就是DHCP数据包)</code><br><strong>【注】Boostrap 是DHCP协议的前身，它叫主机静态配置协议。DHCP其实是它的扩展，将原来静态配置的过程动态化，于是配置起来更加灵活方便，只不过DHCP数据包的依然以Boostrap协议数据包为基础。</strong></p><p>我们点开DHCP看看具体内容：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP具体内容.png" alt="DHCP具体内容"></p><p>通过观察，我们大概可以知道DHCP数据包大概有哪些字段，要了解这些字段的作用，我们还得充分了解协议的具体交互流程。DHCP协议以客户端&lt;-&gt;服务器的方式进行交互，整个过程由客户端主导，服务器被动回应，因此掌握客户端的运行状态，我们就可以掌握DHCP的协议交互流程。</p><h3 id="2-DHCP流程"><a href="#2-DHCP流程" class="headerlink" title="2. DHCP流程"></a>2. DHCP流程</h3><p>DHCP在执行时维护了一个状态机，该状态机由八个状态组成：<br>客户端在运行时维护一个内部状态机，其运行过程如下：</p><ol><li><code>INIT</code>状态。客户端创建一个DHCPDISCOVER消息在局域网内广播，查询可用的DHCP服务器，然后进入<code>SELECTING</code>状态。</li><li><code>SELECTING</code> 状态。局域网内的DHCP收到广播消息后，发送<code>DHCPOFFER</code>消息，客户端会收到一个或多个DHCP服务器的回应，然后它从众多回应中选取一个服务器，向它发送<code>DHCPREQUEST</code>消息，然后进入<code>REQUESTING</code>状态。</li><li><p><code>REQUESTING</code>状态。客户端向服务器发送<code>DHCPREQUEST</code>消息中包含了它对服务器的数据请求，例如可用IP地址以及各类配置参数，请求发送出去后它等待服务器回应。服务器会返回<code>DHCPACK</code>消息，里面包含了客户端想要的可用IP以及配置参数等信息。<br>收到消息后，客户端检测服务器返回的IP地址是否可用，可用的话进入使用状态并像上一节描述的那样设置两个超时时钟。如果客户端发现IP地址不可用，它向服务器发送<code>DHCPDECLINE</code>消息，然后转入状态1。<br>如果客户端从服务器收到的是DHCPNAK消息，它表示服务器拒绝向客户端提供服务，因此客户端重新进入状态1.</p></li><li><p><code>INIT-REBOOT</code>状态。如果客户端已经租借到IP，它重启后进入该状态。此时它会向服务器发送DHCPREQUEST消息，重新确定它对IP的使用权，然后客户端进入REBOOTING状态，等待服务器反应。</p></li><li><p><code>REBOOTING</code>状态。此时客户正在等待服务器返回确认消息，此时会有3中情况。一是客户端收到服务器发来的DHCPACK消息，表明可以继续使用它当前IP,于是客户端进入BOUND状态；二是，客户端得到DHCPACK回应，然后发现它原来使用的IP在自己关机或重启时，被其他设备抢夺了，于是他想服务器发送DHCPDECLINE消息，然后进入状态1；三是收到服务器发来的DHCPNAK消息，这表明服务器告诉客户端IP不能再继续使用，于是客户端进入状态1.</p></li><li><p><code>BOUND</code>状态。此时客户端得到可用IP地址，并进入使用状态。此时它启动两个时钟，T1和T2。当T1超时时，它进入状态RENEWING。如果客户端主动要放弃使用当前IP，它会向服务器发送DHCPRELEASE消息，然后进入状态1.</p></li><li><p><code>RENEWING</code>状态。此时客户端希望续租当前IP，于是他想客户端发送DHCPREQUEST消息，然后等待服务器确认。此时客户端要面临三种情况，一是服务器返回DHCPACK消息，它可以继续使用当前IP；二是收到DHCPNAK消息，服务器拒绝客户端继续租用当前IP；三是客户端的T2时钟超时，客户端进入REBINGDING状态。</p></li><li><p><code>REBIDING</code>状态。此时客户端无法继续续租原有IP，于是它持续向局域网广播DHCPREQUEST消息，直到有服务器响应它为止。此时客户端又面临三种情况。一是有服务器向客户端返回DHCPACK消息，于是客户端可以使用新分配的IP；二是服务器返回DHCPNAK消息，这表明服务器希望客户端重新启动租借流程，于是客户端进入INIT状态；第三是，在收到回应前，客户端当前租用的IP到期，它重新进入INIT状态。</p></li></ol><p>为了简单起见，我们将以客户端的方式编写代码，上面的流程状态可以使用下图统一描述：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/状态机.png" alt="状态机"></p><h3 id="3-字段详解"><a href="#3-字段详解" class="headerlink" title="3. 字段详解"></a>3. 字段详解</h3><p>首先完成第一步，客户端向局域网广播消息，然后收到服务器应答。下面是DHCP消息的具体格式：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP具体格式.png" alt="DHCP具体格式"></p><p>上面的是前面抓包时对应的DHCP部分，依次解析各个字段：</p><ul><li><code>op</code>字段1字节，它表明消息类型，请求消息使用数值1，回应消息使用数值2</li><li><code>HType</code>1字节，它表明消息发送所使用的网络类型，由于我们默认使用互联网，因此它的值固定为1</li><li><code>HLen</code>字段1字节，它表明设备硬件地址的长度，由于我们默认使用mac地址，因此该字段固定为6</li><li><code>Hops</code>字段1字节，它表明数据包可以跨越几个不同网络，该字段的作用我们在前面traceroute程序中了解过，由于我们希望限制消息在当前局域网内流通，因此设置为0</li><li><code>XID</code>字段4字节。它与ICMP消息中的session作用一样，用来标志一次对话过程</li><li><code>Secs</code>字段2字节。它用来表明客户端发出请求后等待的时间，一般该字段不常使用，我们将它固定为0</li><li><code>Flags</code>字段2字节，取值0或1，如果设置为1，客户端要求服务器以广播的方式发送回应消息，因为此时客户端可能还没有IP地址</li><li><code>CIAddr</code>字段4字节，它存放客户端当前IP地址，如果客户端当前有IP，而且进入状态BOUND,RENEWING状态，其他情况下统一设置为0</li><li><code>YIAddr</code>字段4字节，这是服务器返回给客户端使用的IP</li><li><code>SIAddr</code>字段4字节，服务器IP地址，它有点特殊，这个IP是不一定是当前交互的服务器IP，而是设备下次启动时去获取IP地址的服务器IP</li><li><code>GIAddr</code>字段4字节，网关IP，当DHCP服务器不在本地局域网时，设备将通过该IP将数据包转发给处于另一个局域网的服务器，通常情况下使用不到</li><li><code>CHAddr</code>字段16字节，设备的硬件地址。由于我们默认设备使用mac地址，因此只使用到6个字节，其余10个字节用0填充</li><li><code>SName</code>字段64个字节，该字段用做DHCP服务器的字符串名称</li><li><code>File</code>字段128字节，该字段用于在设备和服务器间交换特定信息</li><li><code>Options</code>字段，可变长。该字段用于设备和服务器间交换多种配置信息</li></ul><p>接下来我们看看<code>Options</code>字段，由于所有信息的交互都存储在该字段，因此我们需搞清楚它的结构。在该字段开始前是4个字节的<code>魔术字</code>，固定为<code>99.130.83.99</code>(十六进制：63 82 53 63),然后才是一系列Option数据结构，Option数据结构组成如下：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/option组成.png" alt="option组成"></p><p>每个<code>Option</code>由三字段组成，第一字段是<code>Code</code>,用来表明当前<code>Option</code>类型，它有两个特殊值，一个是<code>0</code>，它表示当前<code>Option</code>只有这一个字节，另一个特殊值是<code>255</code>，它表示后续不再含有<code>Option</code>结构体；第二字段是<code>len</code>，用来标志数据段的长度；第三字段是<code>Data</code>，用来存储数据。</p><p>由于Option结构体用于客户端与服务器进行数据交换，因此它的种类相当繁杂。</p><p>代码实现将在下一篇文章中实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、DHCP介绍&quot;&gt;&lt;a href=&quot;#一、DHCP介绍&quot; class=&quot;headerlink&quot; title=&quot;一、DHCP介绍&quot;&gt;&lt;/a&gt;一、DHCP介绍&lt;/h2&gt;&lt;h3 id=&quot;1-简要介绍&quot;&gt;&lt;a href=&quot;#1-简要介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 简要介绍&quot;&gt;&lt;/a&gt;1. 简要介绍&lt;/h3&gt;&lt;p&gt;DHCP协议在我们日常生活中应该是最常见而又经常被忽略的一种协议了。当你走进一间屋子，手机自动连上了WiFi，当你离开了屋子，又自动断开了WiFi……这一系列的幕后都是DHCP协议在默默工作。&lt;/p&gt;
&lt;p&gt;DHCP协议(Dynamic Host Configuration Protocol)是一个基于UDP协议的局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。&lt;/p&gt;
&lt;p&gt;该协议的做大作用是动态的为加入网络的设备分配IP地址，在该协议出现前，IP地址的分配基于静态模式，你把设备的mac地址手动在路由器设置，然后路由器自动生成一个IP与你的mac地址绑定起来。这种应用在有线网络时代可以适用，但在无线时代，每时每刻可能有不同的设备加入或离开网络，因此原有静态匹配IP的做法不再适合。&lt;/p&gt;
&lt;p&gt;DHCP协议的诞生就是为了迎合在无线情况下，网络内部连接设备不断变化的情况。它包含两部分，一是分配IP地址，二是支持客户端请求，服务器应答，使得两者之间有效交换配置信息。&lt;/p&gt;
&lt;p&gt;DHCP最重要功能显然是动态分配IP地址，当我们的设备连接上网络之后里面获得一个可用的IP地址，就得感谢该协议的执行，现在我们大多数设备都依靠DHCP来从路由器动态获得IP&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://CherryYang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP协议" scheme="http://CherryYang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="计算机网络" scheme="http://CherryYang05.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP协议" scheme="http://CherryYang05.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="DHCP" scheme="http://CherryYang05.github.io/tags/DHCP/"/>
    
  </entry>
  
  <entry>
    <title>开源镜像网站</title>
    <link href="http://cherryyang05.github.io/2020/05/13/%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99/"/>
    <id>http://cherryyang05.github.io/2020/05/13/%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99/</id>
    <published>2020-05-13T06:32:31.000Z</published>
    <updated>2020-05-13T06:42:56.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些开源镜像网站汇总"><a href="#一些开源镜像网站汇总" class="headerlink" title="一些开源镜像网站汇总"></a>一些开源镜像网站汇总</h2><h4 id="开源网站镜像"><a href="#开源网站镜像" class="headerlink" title="开源网站镜像"></a>开源网站镜像</h4><ul><li>搜狐开源镜像站：<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a></li><li>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></li><li>开源中国：<a href="http://mirrors.oschina.net/" target="_blank" rel="noopener">http://mirrors.oschina.net/</a></li><li>首都在线科技股份有限公司：<a href="http://mirrors.yun-idc.com/" target="_blank" rel="noopener">http://mirrors.yun-idc.com/</a></li><li>阿里云开源镜像：<a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com/</a></li><li>LUPA：<a href="http://mirror.lupaworld.com/" target="_blank" rel="noopener">http://mirror.lupaworld.com/</a></li><li>常州贝特康姆软件技术有限公司(原cn99）：<a href="http://centos.bitcomm.cn/" target="_blank" rel="noopener">http://centos.bitcomm.cn/</a></li></ul><a id="more"></a><h4 id="大学校园镜像"><a href="#大学校园镜像" class="headerlink" title="大学校园镜像"></a>大学校园镜像</h4><ul><li>中山大学镜像：<a href="http://mirror.sysu.edu.cn/" target="_blank" rel="noopener">http://mirror.sysu.edu.cn/</a></li><li>山东理工大学：<a href="http://mirrors.sdutlinux.org/" target="_blank" rel="noopener">http://mirrors.sdutlinux.org/</a></li><li>哈尔滨工业大学：<a href="http://run.hit.edu.cn/" target="_blank" rel="noopener">http://run.hit.edu.cn/</a></li><li>中国地质大学：<a href="http://cugbteam.org/" target="_blank" rel="noopener">http://cugbteam.org/</a></li><li>大连理工大学：<a href="http://mirror.dlut.edu.cn/" target="_blank" rel="noopener">http://mirror.dlut.edu.cn/</a></li><li>西南林业大学 <a href="http://cs3.swfu.edu.cn/cs3guide.html" target="_blank" rel="noopener">http://cs3.swfu.edu.cn/cs3guide.html</a></li><li>北京化工大学（仅教育网可以访问），包含 CentOS 镜像：<a href="http://ubuntu.buct.edu.cn/" target="_blank" rel="noopener">http://ubuntu.buct.edu.cn/</a></li><li>天津大学：<a href="http://mirror.tju.edu.cn/" target="_blank" rel="noopener">http://mirror.tju.edu.cn/</a></li><li>西南大学：<a href="http://linux.swu.edu.cn/swudownload/Distributions/" target="_blank" rel="noopener">http://linux.swu.edu.cn/swudownload/Distributions/</a></li><li>青岛大学：<a href="http://mirror.qdu.edu.cn/" target="_blank" rel="noopener">http://mirror.qdu.edu.cn/</a></li><li>南京师范大学：<a href="http://mirrors.njnu.edu.cn/" target="_blank" rel="noopener">http://mirrors.njnu.edu.cn/</a></li><li>大连东软信息学院： <a href="http://mirrors.neusoft.edu.cn/" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/</a></li><li>浙江大学：<a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></li><li>兰州大学：<a href="http://mirror.lzu.edu.cn/" target="_blank" rel="noopener">http://mirror.lzu.edu.cn/</a></li><li>厦门大学：<a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="noopener">http://mirrors.xmu.edu.cn/</a></li><li>北京理工大学：<br><a href="http://mirror.bit.edu.cn" target="_blank" rel="noopener">http://mirror.bit.edu.cn</a> (IPv4 only)<br><a href="http://mirror.bit6.edu.cn" target="_blank" rel="noopener">http://mirror.bit6.edu.cn</a> (IPv6 only)</li><li>北京交通大学：<br><a href="http://mirror.bjtu.edu.cn" target="_blank" rel="noopener">http://mirror.bjtu.edu.cn</a> (IPv4 only)<br><a href="http://mirror6.bjtu.edu.cn" target="_blank" rel="noopener">http://mirror6.bjtu.edu.cn</a> (IPv6 only)<br><a href="http://debian.bjtu.edu.cn" target="_blank" rel="noopener">http://debian.bjtu.edu.cn</a> (IPv4+IPv6)</li><li>上海交通大学：<br><a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/</a> (IPv4 only)<br><a href="http://ftp6.sjtu.edu.cn" target="_blank" rel="noopener">http://ftp6.sjtu.edu.cn</a> (IPv6 only)</li><li>清华大学：<br><a href="http://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors.6.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.6.tuna.tsinghua.edu.cn/</a> (IPv6 only)<br><a href="http://mirrors.4.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.4.tuna.tsinghua.edu.cn/</a> (IPv4 only)</li><li>中国科学技术大学：<br><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors4.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors4.ustc.edu.cn/</a><br><a href="http://mirrors6.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors6.ustc.edu.cn/</a></li><li>东北大学：<br><a href="http://mirror.neu.edu.cn/" target="_blank" rel="noopener">http://mirror.neu.edu.cn/</a> (IPv4 only)<br><a href="http://mirror.neu6.edu.cn/" target="_blank" rel="noopener">http://mirror.neu6.edu.cn/</a> (IPv6 only)</li><li>华中科技大学：<br><a href="http://mirrors.hust.edu.cn/" target="_blank" rel="noopener">http://mirrors.hust.edu.cn/</a><br><a href="http://mirrors.hustunique.com/" target="_blank" rel="noopener">http://mirrors.hustunique.com/</a></li><li>电子科技大学：<a href="http://ubuntu.uestc.edu.cn/" target="_blank" rel="noopener">http://ubuntu.uestc.edu.cn/</a></li><li>电子科大凝聚工作室(Raspbian单一系统镜像) <a href="http://raspbian.cnssuestc.org/" target="_blank" rel="noopener">http://raspbian.cnssuestc.org/</a></li><li>电子科大星辰工作室(少数小众发布版镜像) <a href="http://mirrors.stuhome.net/" target="_blank" rel="noopener">http://mirrors.stuhome.net/</a></li></ul><h4 id="PyPi-镜像"><a href="#PyPi-镜像" class="headerlink" title="PyPi 镜像"></a>PyPi 镜像</h4><ul><li>豆瓣：<a href="http://pypi.douban.com/" target="_blank" rel="noopener">http://pypi.douban.com/</a></li><li>山东理工大学：<a href="http://pypi.sdutlinux.org/" target="_blank" rel="noopener">http://pypi.sdutlinux.org/</a></li><li>中山大学：<a href="http://mirror.sysu.edu.cn/pypi/" target="_blank" rel="noopener">http://mirror.sysu.edu.cn/pypi/</a></li><li>V2EX：<a href="http://pypi.v2ex.com/simple/" target="_blank" rel="noopener">http://pypi.v2ex.com/simple/</a></li><li><p>RubyGems 镜像</p></li><li><p>中山大学：<a href="http://mirror.sysu.edu.cn/rubygems/" target="_blank" rel="noopener">http://mirror.sysu.edu.cn/rubygems/</a></p></li><li>山东理工大学：<a href="http://ruby.sdutlinux.org/" target="_blank" rel="noopener">http://ruby.sdutlinux.org/</a></li><li>淘宝网：<a href="http://ruby.taobao.org/" target="_blank" rel="noopener">http://ruby.taobao.org/</a></li></ul><h4 id="npm-镜像"><a href="#npm-镜像" class="headerlink" title="npm 镜像"></a>npm 镜像</h4><ul><li>cnpmjs：<a href="http://cnpmjs.org/" target="_blank" rel="noopener">http://cnpmjs.org/</a></li></ul><p>附Debian各个版本的下载地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 以下为debian-9.6版的下载地址，不同镜像对应不同的Linux桌面环境</span><br><span class="line"> </span><br><span class="line"># 官网下载地址 共三个镜像文件，一般只下载第一个就行了，当然也可以全部现在，启动时先选择第一个光盘，如果你安装的时候选择的软件比较多，可能会提示你插入第二张或者第三张光盘</span><br><span class="line">链接：https:&#x2F;&#x2F;cdimage.debian.org&#x2F;debian-cd&#x2F;current&#x2F;i386&#x2F;iso-dvd&#x2F;debian-9.6.0-i386-DVD-1.iso</span><br><span class="line">链接：https:&#x2F;&#x2F;cdimage.debian.org&#x2F;debian-cd&#x2F;current&#x2F;i386&#x2F;iso-dvd&#x2F;debian-9.6.0-i386-DVD-2.iso</span><br><span class="line">链接：https:&#x2F;&#x2F;cdimage.debian.org&#x2F;debian-cd&#x2F;current&#x2F;i386&#x2F;iso-dvd&#x2F;debian-9.6.0-i386-DVD-3.iso</span><br><span class="line"> </span><br><span class="line"># 这下面时163网站给出的镜像，而且是分成不同的桌面版本来下载的，如果不想折腾，可以直接选择下面一个镜像进行下载。</span><br><span class="line"># 事先可以搜索一下Debian的各种桌面  cinnamon&#x2F;gnome(主流)&#x2F;kde(主流)&#x2F;lxde&#x2F;mate&#x2F;xfce</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-cinnamon.iso    下载地址</span><br><span class="line">链接：http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-cinnamon.iso</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-gnome.iso     下载地址</span><br><span class="line">链接：http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-gnome.iso</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-kde.iso  下载地址</span><br><span class="line">链接：http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-kde.iso</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-lxde.iso    下载地址</span><br><span class="line">链接：http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-lxde.iso</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-mate.iso     下载地址</span><br><span class="line">链接: http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-mate.iso</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-xfce.iso     下载地址</span><br><span class="line">链接：http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-xfce.iso</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些开源镜像网站汇总&quot;&gt;&lt;a href=&quot;#一些开源镜像网站汇总&quot; class=&quot;headerlink&quot; title=&quot;一些开源镜像网站汇总&quot;&gt;&lt;/a&gt;一些开源镜像网站汇总&lt;/h2&gt;&lt;h4 id=&quot;开源网站镜像&quot;&gt;&lt;a href=&quot;#开源网站镜像&quot; class=&quot;headerlink&quot; title=&quot;开源网站镜像&quot;&gt;&lt;/a&gt;开源网站镜像&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;搜狐开源镜像站：&lt;a href=&quot;http://mirrors.sohu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.sohu.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;网易开源镜像站：&lt;a href=&quot;http://mirrors.163.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.163.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开源中国：&lt;a href=&quot;http://mirrors.oschina.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.oschina.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;首都在线科技股份有限公司：&lt;a href=&quot;http://mirrors.yun-idc.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.yun-idc.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;阿里云开源镜像：&lt;a href=&quot;http://mirrors.aliyun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.aliyun.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LUPA：&lt;a href=&quot;http://mirror.lupaworld.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirror.lupaworld.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;常州贝特康姆软件技术有限公司(原cn99）：&lt;a href=&quot;http://centos.bitcomm.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://centos.bitcomm.cn/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://CherryYang05.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="开源镜像" scheme="http://CherryYang05.github.io/tags/%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F/"/>
    
      <category term="系统" scheme="http://CherryYang05.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://CherryYang05.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>BAT批处理文件的使用（二）</title>
    <link href="http://cherryyang05.github.io/2020/05/09/BAT%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://cherryyang05.github.io/2020/05/09/BAT%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-05-09T10:44:22.000Z</published>
    <updated>2020-05-09T10:46:31.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等"><a href="#BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等" class="headerlink" title="BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等"></a>BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等</h2><p>前两天在使用 VSCode 的时候，看到之前那么多 cpp 编译产生的 exe 可执行文件，于是心生一个念头，我要把它们全部删掉，但是又不想一个个地删，便想到了利用 <code>bat</code> 脚本批量删除 exe 文件。于是在搜集了大量资料后，开始了编写。<br><a id="more"></a><br>首先就是一条简单的 <code>del</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del F:\Code\C++\*.exe</span><br></pre></td></tr></table></figure><br>但是发现只能删除掉 <code>C++</code> 那个文件夹根目录下的 exe 文件，然后发现，在后面加上 <code>/s</code>，表示在当前目录递归删除指定文件，就是还要进入子目录寻找文件。</p><blockquote><p>/a 根据百属性选择要删除的文件<br>/f 强制删除只读度文件<br>/s 从所有子目录删除指定文件<br>/q 安静模式。删除全局通配符时，不要求确知</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del F:\Code\C++\*.exe /s</span><br></pre></td></tr></table></figure><p>运行之后，哗啦啦，全删掉了(在其他盘里测试一下)：<br><img src="https://img-blog.csdnimg.cn/20200509172606608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>本来其实这样就可以了，把这个批处理脚本放到 C++ 文件夹根目录就行了，但是如果多次执行的时候，本来已经没有 exe 文件了，还要执行，就会提示 <code>找不到 G:\test\*.exe</code>，对于强迫症的我当然不能忍受起码提示一个 <code>exe文件已经删完啦</code> 之类的。要这样写势必要进行条件判断，然后，又去找了很多资料。<br>一开始搜到一个 <code>errorlevel</code> 的系统变量，会判断你当前这条语句是否执行，如果成功执行该变量的值为 <code>0</code>， 否则是 <code>1-255</code> 之间的某一个值，这里的值主要是根据语句未能成功执行的原因（其实就是跟中断类型差不多）来决定的，一般是 <code>1</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line">if ERRORLEVEL 1 goto fail</span><br><span class="line">if ERRORLEVEL 0 goto success</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del F:\Code\C++\*.exe /s</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br>运行后发现了中文乱码，于是改一下编码为 <code>ANSI</code><img src="https://img-blog.csdnimg.cn/20200509174008621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后再次执行，发现不管 <code>exe</code> 文件是否被删掉，都会执行 <code>success</code> 标号的语句，说明 <code>del</code> 语句都被执行了，只是找不到文件而已。<br><img src="https://img-blog.csdnimg.cn/20200509174405846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种方法不行那就试试其他方法，用 <code>if exist</code> 条件判断应该可以吧<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line">::if ERRORLEVEL 1 goto fail</span><br><span class="line">::if ERRORLEVEL 0 goto success</span><br><span class="line">if exist F:\Code\C++\*.exe (goto success) else (goto fail)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del F:\Code\C++\*.exe /s</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br>这里的 <code>::</code>是注释，当然注释还有其他写法</p><blockquote><p>1、:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）<br>    2、rem 注释内容（不能出现重定向符号和管道符号）<br>    3、echo 注释内容（不能出现重定向符号和管道符号）〉nul<br>    4、if not exist nul 注释内容（不能出现重定向符号和管道符号）<br>    5、:注释内容（注释文本不能与已有标签重名）<br>    6、%注释内容%（可以用作行间注释，不能出现重定向符号和管道符号）<br>    7、goto 标签 注释内容（可以用作说明goto的条件和执行内容）<br>    8、:标签 注释内容（可以用作标签下方段的执行内容</p></blockquote><p>完美执行。<br>然后在之后的其他测试中，若 <code>C++</code> 根目录下没有 <code>exe</code> 文件，而在其子文件夹下有 <code>exe</code> 文件的话，就出问题了，因为 <code>if exist</code> 那行语句只是判断当前文件夹根目录下是否存在 <code>exe</code> 文件。那该怎么办呢？<br>应该要对 <code>C++</code> 根目录进行递归查找，便是 <code>for</code> 语句：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cls</span><br><span class="line">set PATH=F:\Code\C++\</span><br><span class="line">set FILE=*.exe</span><br><span class="line">set cnt=0</span><br><span class="line">for /R %PATH% %%s in (%FILE%) do (</span><br><span class="line">::echo %%s</span><br><span class="line">set /a cnt=%cnt%+1</span><br><span class="line">)</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">if %cnt% EQU 0 (goto fail) else (goto success)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del *.exe /s</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">goto done</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br><code>for</code> 循环后面的 <code>/R</code> 便是对当前文件夹进行递归查找，若存在后缀名为 <code>.exe</code> 文件，便把计数值+1.然后运行，又出错了。。。<br>cnt的值始终为1，这又是为什么呢？<br>又查了许多资料，发现 批处理语法中还有叫什么 <code>变量延迟</code> 的语法，具体就是 <strong>当我们准备执行一条命令的时候，命令解释器会先将命令读取，如果命令中有环境变量，那么就会将变量的值先读取来出，然后在运行这条命令</strong>，如：<code>echo %cnt%</code>，当我们执行这条命令的时候，命令解释器会先读出 <code>%cnt%</code> 的值，然后执行echo，得到的结果是屏幕上显示出 <code>cnt的值</code>。但是，有的时候，我们在执行一条命令的时候，命令解释器将环境变量的值读出来以后，我们的环境变量的值发生了改变，这时个再执行命令就是使用的变量改变前的值，这就不是我们想要的结果了。<br>也就是，当 <code>for</code> 语句执行时，命令解释器首先把它变成<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /R %s in (*.exe) do (set /a cnt=0+1 )</span><br></pre></td></tr></table></figure><br>因此在这个循环里面 <code>cnt</code> 就全是0了，这里我们就需要用到 <code>变量延迟</code> 了，设置 <code>setlocal enabledelayedexpansion</code>，然后将需要使用变量延迟的变量两边用 <code>!</code> 表示，即 <code>set /a cnt=!cnt!+1</code>.<br>关闭变量延迟的话就是 <code>setlocal disabledelayedexpansion</code>.<br>全部修改完了 <code>bat</code> 程序如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cls</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">set PATH=F:\Code\C++\</span><br><span class="line">set FILE=*.exe</span><br><span class="line">set cnt=0</span><br><span class="line">for /R %PATH% %%s in (%FILE%) do (</span><br><span class="line">::echo %%s</span><br><span class="line">set /a cnt=!cnt!+1</span><br><span class="line">)</span><br><span class="line">if %cnt% EQU 0 (goto fail) else (goto success)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del %PATH%%FILE% /s</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">goto done</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br><span class="line">endlocal</span><br></pre></td></tr></table></figure><p>大功告成！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等&quot;&gt;&lt;a href=&quot;#BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等&quot; class=&quot;headerlink&quot; title=&quot;BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等&quot;&gt;&lt;/a&gt;BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等&lt;/h2&gt;&lt;p&gt;前两天在使用 VSCode 的时候，看到之前那么多 cpp 编译产生的 exe 可执行文件，于是心生一个念头，我要把它们全部删掉，但是又不想一个个地删，便想到了利用 &lt;code&gt;bat&lt;/code&gt; 脚本批量删除 exe 文件。于是在搜集了大量资料后，开始了编写。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="BAT批处理" scheme="http://CherryYang05.github.io/categories/BAT%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
    
      <category term="BAT" scheme="http://CherryYang05.github.io/tags/BAT/"/>
    
      <category term="批处理" scheme="http://CherryYang05.github.io/tags/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
      <category term="脚本" scheme="http://CherryYang05.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>密码学（二）：古典密码之维吉尼亚密码的破解</title>
    <link href="http://cherryyang05.github.io/2020/05/06/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E7%9A%84%E7%A0%B4%E8%A7%A3/"/>
    <id>http://cherryyang05.github.io/2020/05/06/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E7%9A%84%E7%A0%B4%E8%A7%A3/</id>
    <published>2020-05-06T09:08:39.000Z</published>
    <updated>2020-05-06T11:41:27.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="维吉尼亚密码的破解"><a href="#维吉尼亚密码的破解" class="headerlink" title="维吉尼亚密码的破解"></a>维吉尼亚密码的破解</h2><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>&emsp;&emsp;上一章我们介绍了维吉尼亚密码的原理，是通过移位替换的加密方法进行加密，但是因为概率论的出现这种简单的移位或替换就容易破解了，其原理很简单，英文中字母出现的频率是不一样的。比如字母 <strong>e</strong> 是出现频率最高的，占<strong>12.7%</strong>；其次是<strong>t</strong>，<strong>9.1%</strong>；然后是<strong>a</strong>，<strong>o</strong>，<strong>i</strong>，<strong>n</strong>等，最少的是<strong>z</strong>，只占<strong>0.1%</strong>。<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20200216150747368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="字母出现概率"></p><p><a id="具体概率表">具体概率表</a></p><p><img src="https://img-blog.csdnimg.cn/20200216161337882.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_26,color_FFFFFF,t_70" width="450" height="500" alt="概率表" style="margin-left:50px"></p><p>除了英语，其他语言也有相关统计（<a href="https://www.cnblogs.com/inverseEntropy/p/10151176.html" target="_blank" rel="noopener">图片来源</a>）<br><img src="https://img-blog.csdnimg.cn/20200216150833315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="多种语言的字母出现频率"></p><h3 id="二、一般破解的方法"><a href="#二、一般破解的方法" class="headerlink" title="二、一般破解的方法"></a>二、一般破解的方法</h3><h4 id="1-穷举密钥搜索"><a href="#1-穷举密钥搜索" class="headerlink" title="1. 穷举密钥搜索"></a>1. 穷举密钥搜索</h4><p>&emsp;&emsp;只适用于与小的密钥空间，而像维吉尼亚密码的 $Z^n_{26}$ 是 26 的 n 次方的空间，当 n 很大时，计算量是相当大的。</p><h4 id="2-频率统计"><a href="#2-频率统计" class="headerlink" title="2. 频率统计"></a>2. 频率统计</h4><h5 id="单表代换"><a href="#单表代换" class="headerlink" title="单表代换"></a>单表代换</h5><p><strong>移位密码：</strong> 相同的明文字母总是对应相同的密文字母，因此，尽管字母的外形改变了，他出现的概率还是不变的，只要根据足够多的样例来进行统计，最终密文字母的出现概率总是近似于明文字母的出现概率，并且与之一一对应。</p><h5 id="多表代换"><a href="#多表代换" class="headerlink" title="多表代换"></a>多表代换</h5><p><strong>维吉尼亚密码：</strong> 相同的明文字母可能对应不同的密文字母，这里讲的维吉尼亚密码的破解也是根据字母出现的频率的蛛丝马迹进行破解。</p><h3 id="三、维吉尼亚密码的破解"><a href="#三、维吉尼亚密码的破解" class="headerlink" title="三、维吉尼亚密码的破解"></a>三、维吉尼亚密码的破解</h3><h4 id="1-确定密钥长度"><a href="#1-确定密钥长度" class="headerlink" title="1. 确定密钥长度"></a>1. 确定密钥长度</h4><h5 id="方法一：Kasiski测试法"><a href="#方法一：Kasiski测试法" class="headerlink" title="方法一：Kasiski测试法"></a>方法一：Kasiski测试法</h5><p><strong>原理：密文中出现两个相同字母组，它们所对应的明文字母相同的可能性很大，这样的两个密文字母组之间的距离可能为密钥长度的整数倍。</strong><br><img src="https://img-blog.csdnimg.cn/2020021617084725.jpg" alt="在这里插入图片描述"><br>&emsp;&emsp;尽管在维吉尼亚密码中相同的明文可能对应不同的密文，但是若连续出现相同的密文，那么用同样的密钥加密的概率会大大增加。这里密文 $ZB$ 都是用 $HI$ 加密，计算两者之间的距离为 $5$，因此可推断出来密钥长度为 $5.$</p><h5 id="方法二：重合指数法"><a href="#方法二：重合指数法" class="headerlink" title="方法二：重合指数法"></a>方法二：重合指数法</h5><p><strong>原理：自然语言（以英语为例）的重合指数约为 0.065，而且单标代换不会改变该值。</strong><br><strong>重合指数定义：</strong></p><p>设 <script type="math/tex">x=x_1x_2...x_n</script> 是含有 $n$ 个字母的串，则在 $x$ 中随机选择两个元素且这两个元素相同的概率为：</p><p>定义：$f_i$ 为 26 个字母中第 $i$ 个字母在 $x$ 中出现的次数</p><p>[例如：$x=AAZZZ,n=5,f_0=2,f_{25}=3$，第一次取出 A 的概率为 $\frac {f_0} {n}$，第二次再取出 A 的概率为 $\frac {f_0} {n} * \frac {f_0-1} {n-1}$]</p><p>当我们把 26 个字母的概率全部相加，得到的总的概率就是<strong>重合指数</strong>：</p><script type="math/tex; mode=display">I_c(x)={\frac {\displaystyle\sum_{i=0}^{25}f_i(f_i-1)} {n(n-1)} }</script><p>当计算的数量很大时，我们将 $n(n-1)$ 近似为 $n^2$，将 $f_i(f_i-1)$ 近似为 $f_i^2$</p><p>因此</p><script type="math/tex; mode=display">I_c(x) \approx \displaystyle\sum_{i=0}^{25} {p_i^2} \approx0.065</script><p>这里的 $p_i$ 表示第 $i$ 个字母在英语语言中出现的概率，就是在<a href="#具体概率表">引言</a>中列出的数值。<br>这个数值非常重要。</p><p><strong>注意：在单表代换中，不会改变该值，也就是用相同密钥字加密应服从相同的重合指数。</strong></p><h5 id="猜测密钥长度"><a href="#猜测密钥长度" class="headerlink" title="猜测密钥长度"></a>猜测密钥长度</h5><p>&emsp;&emsp;假设密钥长度为 $d$，提取相同密钥字加密的密文，测试其重合指数。<br>&emsp;&emsp;如果猜测正确，则重合指数接近 $0.065$，否则字符串表现得更加随机一般在 $0.038(1/26) \thicksim 0.065$ 之间。<br><img src="https://img-blog.csdnimg.cn/20200216184236771.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="猜测密钥长度"><br>&emsp;&emsp;在这里，我们先猜测密钥长度为 5，然后将密文按照 5 进行分组，分别提取出用密钥 $k_1,k_2,k_3,k_4,k_5$ 加密的密文，组成集合 $C_1,C_2,C_3,C_4,C_5$，这样就把多表代换转化成了单表代换。<br>这里 $C_1=\{Z,P,L,W,Z\},C_2=\{P,A,Z,Z,N\},C_3=\{D,Z,B,B,M\},C_4=\{X,H,H,K\},C_5=\{V,S,I,M\}$</p><p>以一个例子为例：<br><img src="https://img-blog.csdnimg.cn/20200216214722472.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;$CHR$ 这三个字符出现频率较高，因此我们将其位置记录下来，测算他们之间的距离，并取最大公因数 5，猜测 5 便是密钥长度。这很有可能是相同的明文被相同的密文加密了。其实很容易猜到，这很可能是英语当中的定冠词 <strong>the</strong>.</p><p>我们在用重合指数法进行测试，分别测试 $d=1,2,3,4,5$ （过程略）</p><div class="table-container"><table><thead><tr><th>$d$</th><th>重合指数</th></tr></thead><tbody><tr><td>$1$</td><td>$[0.045]$</td></tr><tr><td>$2$</td><td>$[0.046,0.041]$</td></tr><tr><td>$3$</td><td>$[0.043,0050,0.047]$</td></tr><tr><td>$4$</td><td>$[0.042,0.039,0.046,0.040]$</td></tr><tr><td>$5$</td><td>$[0.063,0.068,0.069,0.061,0.072]$</td></tr></tbody></table></div><p>&emsp;&emsp;观察发现，只有当 $d=5$ 的时候，重合指数接近 $0.065$，因此刚刚的猜测 $d=5$ 是正确的，这时通过穷举密钥的复杂度为 $26^5$，但是仍然比较大。</p><h4 id="2-确定密钥字相对位移"><a href="#2-确定密钥字相对位移" class="headerlink" title="2. 确定密钥字相对位移"></a>2. 确定密钥字相对位移</h4><p>密钥字的相对位移实际上就是确定密钥之间的相互关系。<br>这里引入一个定义：</p><p><strong>重合互指数:</strong><br>&emsp;&emsp;设 $x=x_1,x_2,…,x_n,y=y_1,y_2,…,y_{n’}$，分别为长度为 $n$ 和 $n’$ 的串，其重合互指数为从 $x$ 和 $y$ 中分别随机选出一个元素且两个元素相同的概率。</p><p>计算方法和刚刚的计算方法类似：</p><script type="math/tex; mode=display">MI_c(x,y)=\frac{\displaystyle\sum_{i=0}^{25}f_if'_i}{nn'}</script><p>具体不再阐述。</p><p>&emsp;&emsp;考虑不同密钥字加密后密文串的重合互指数，设密钥字为 $k=k_1k_2…k_d$，$C_i$ 中的一个字母与 $C_j$ 中的一个字母都是 $A$ 的概率为 $p_{0-k_i}p_{0-k_j}$.</p><p>其中 $p_{0-k_i}$ 为密文 $A$ 所对应明文字母的出现概率。同理可以计算 $B,C,D,…,Z$，因此：</p><script type="math/tex; mode=display">MI_c(C_i,C_j) \approx \displaystyle\sum_{l=0}^{25}p_{l-k_i}p_{l-k_j}=\displaystyle\sum_{l=0}^{25}p_lp_{l+k_i-k_j}=\displaystyle\sum_{l=0}^{25}p_{l-k_i+k_j}p_l</script><p>这里的下标是需要对 26 取模的，可以观察到：$Mi_c$ 取决于相对位移 $k_i-k_j$.</p><p>移位表如下：<br><img src="https://img-blog.csdnimg.cn/20200216224709354.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="500"><br>观察这里当相对距离为0时，重合互指数为 $0.065$，在之前提到的自然语言的重合互指数也是 $0.065$，这并不是巧合。当相对位移位 0 时，其实就是 $C_1,C_2$ 的集合是用同一种密文加密得到，这也就是单表代换这样，并不会改变重合指数。</p><p>这里其实并不需要列举从 0 到 25 的所有值。</p><h5 id="猜测不同密钥字的相对位移s（猜测范围0-25）"><a href="#猜测不同密钥字的相对位移s（猜测范围0-25）" class="headerlink" title="猜测不同密钥字的相对位移s（猜测范围0~25）"></a>猜测不同密钥字的相对位移s（猜测范围0~25）</h5><script type="math/tex; mode=display">MI_c(C_i,C_j)=\frac{\displaystyle\sum_{t=0}^{25}f_{i,t}f_{j,t-s} } {n_in_j}</script><p>&emsp;&emsp;这里 $n_i$ 是指集合 $C_i$ 中字符个数，这里 $n_j$ 是指集合 $C_j$ 中字符个数，$f_{i,t}$ 表示在集合 $C_i$ 中，$t$ 这个密文字符出现的次数，$f_{j,t-s}$ 表示在集合 $C_j$ 中，$t-s$ 这个密文字符出现的次数。</p><p>&emsp;&emsp;如果猜对 $s$，那么 $MI_c$ 应该接近 $0.065$，这意味着找到了<strong>不同密钥字加密的相同的明文字母</strong>，这也就找到了密钥字之间的相对位移，也就转化成了单表代换。<br>这里用 $m$ 表示明文字母，$c,c’$ 分别表示 $C_i,C_j$ 中 $m$ 对应的密文字母，那么：</p><script type="math/tex; mode=display">m=c-k_i \pmod{26} \\ m=c'-k_j \pmod{26}</script><p>&emsp;&emsp;实际上，在维吉尼亚密码中，并没有很好的隐藏密钥和密文之间的相互关系，密钥之间的相互差距会体现在密文之间的相互关系。</p><p>&emsp;&emsp;我们计算上面例子中的集合 $C_1,C_2,C_3,C_4,C_5$ 两两之间的重合互指数：</p><p><img src="https://img-blog.csdnimg.cn/20200216231804835.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="550"></p><p>&emsp;&emsp;这里的 $i,j$ 表示当取到不同集合的时候，后面的值表示当猜测的相对位移 $s$ 取不同值的时候重合互指数的结果。</p><p>&emsp;&emsp;我们观察结果，当 $i=1,j=2,s=9$ 时，重合互指数达到了 $0.068$，因此可以得到 $k_1-k_2=9$.<br>&emsp;&emsp;但是当 $i=1,j=3;i=1,j=4$ 时，没有合适的相对位移，那么我们先暂时跳过，观察其他结果，发现当 $i=1,j=5,s=16$ 时，重合互指数达到 $0.070$，$i=2,j=3,s=13$ 的时候，重合互指数达到了 $0.067$.<br><img src="https://img-blog.csdnimg.cn/2020021623254417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="550"><br>我们列举完剩下的结果，得到：</p><script type="math/tex; mode=display">k_1-k_2=9 \\ k_1-k_5=16 \\ k_2-k_3=13 \\ k_2-k_5=7 \\ k_3-k_5=20 \\ k_4-k_5=11</script><h4 id="3-穷举搜索密钥字"><a href="#3-穷举搜索密钥字" class="headerlink" title="3. 穷举搜索密钥字"></a>3. 穷举搜索密钥字</h4><p>&emsp;&emsp;根据上述的结果，在确定密钥字之间关系式的基础上，只要穷举 $26$ 中可能性就可以了。因为当猜测 $k_1$ 的时候， $k_2$ 也就确定下来了，以此类推，剩下的几个密钥也就确定下来了，只要从 $A-Z$ 进行穷举即可。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>&emsp;&emsp;一个好的密码加密方案（或者说是算法），应该要很好的隐藏密钥和密文之间的联系，通过更复杂的算法或者在更大的密钥空间中，可以有效避免穷举搜索破解。如何设计加密算法以及如何选择合适的密钥空间，将在今后继续学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;维吉尼亚密码的破解&quot;&gt;&lt;a href=&quot;#维吉尼亚密码的破解&quot; class=&quot;headerlink&quot; title=&quot;维吉尼亚密码的破解&quot;&gt;&lt;/a&gt;维吉尼亚密码的破解&lt;/h2&gt;&lt;h3 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;上一章我们介绍了维吉尼亚密码的原理，是通过移位替换的加密方法进行加密，但是因为概率论的出现这种简单的移位或替换就容易破解了，其原理很简单，英文中字母出现的频率是不一样的。比如字母 &lt;strong&gt;e&lt;/strong&gt; 是出现频率最高的，占&lt;strong&gt;12.7%&lt;/strong&gt;；其次是&lt;strong&gt;t&lt;/strong&gt;，&lt;strong&gt;9.1%&lt;/strong&gt;；然后是&lt;strong&gt;a&lt;/strong&gt;，&lt;strong&gt;o&lt;/strong&gt;，&lt;strong&gt;i&lt;/strong&gt;，&lt;strong&gt;n&lt;/strong&gt;等，最少的是&lt;strong&gt;z&lt;/strong&gt;，只占&lt;strong&gt;0.1%&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="密码学" scheme="http://CherryYang05.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="http://CherryYang05.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="古典密码" scheme="http://CherryYang05.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    
      <category term="维吉尼亚密码" scheme="http://CherryYang05.github.io/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>密码学（一）：古典密码之维吉尼亚密码介绍</title>
    <link href="http://cherryyang05.github.io/2020/05/06/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E4%BB%8B%E7%BB%8D/"/>
    <id>http://cherryyang05.github.io/2020/05/06/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-05-06T08:55:26.000Z</published>
    <updated>2020-05-06T09:06:59.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="维吉尼亚（Vigenere-Cipher）密码原理介绍"><a href="#维吉尼亚（Vigenere-Cipher）密码原理介绍" class="headerlink" title="维吉尼亚（Vigenère Cipher）密码原理介绍"></a>维吉尼亚（Vigenère Cipher）密码原理介绍</h2><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><blockquote><p>&emsp;&emsp;维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。<br>&emsp;&emsp;维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。<br>&emsp;&emsp;维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”（法语：le chiffre indéchiffrable）。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。<br>来源：<a href="https://baike.baidu.com/item/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/4905472?fr=aladdin" target="_blank" rel="noopener">百度百科</a><br><img src="https://img-blog.csdnimg.cn/20200216154546299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a id="more"></a></p><h3 id="二、古典密码"><a href="#二、古典密码" class="headerlink" title="二、古典密码"></a>二、古典密码</h3><h4 id="1-移位密码"><a href="#1-移位密码" class="headerlink" title="1. 移位密码"></a>1. 移位密码</h4><p>我们首先引入符号表示：<br>$P$：明文空间，所有可能的明文组成的有限集<br>$C$：密文空间，所有可能的密文组成的有限集<br>$K$：密钥空间，所有可能的密钥 $k$ 组成的有限集<br>$Enc$：加密算法<br>&emsp;&emsp;$Enc_k(m)=c$ 加密算法$Enc$以密钥$k$、明文$m$为输入，输出密文$c$<br>$Dec$：加密算法<br>&emsp;&emsp;$Dec_k(c)=m$ 解密算法$Dec$以密钥$k$、密文$c$为输入，输出明文$m$<br>算法正确性：对每个明文 $m\in P$ 以及秘钥 $k\in K$ 都有 $Dec_k(Enc_k(m))=m$</p></blockquote><p>其中最典型的移位密码就是凯撒密码，凯撒密码是通过移位替换的方法，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。</p><script type="math/tex; mode=display">令P=C=K=Z_{26}=\{ 0,1,2,3,...,25 \} \\随机选择 K \in Z_{26} 作为密钥 \\Enc_k(m)=m+k \pmod {26} \\Dec_k(c)=c-k\pmod{26}</script><p>其中 $Z_{26}$ 是26个英文字母组成的集合空间。<br>例如，当偏移量$k$是3的时候，所有的字母A将被替换成D，B变成E … Z变成C，以此类推。</p><h4 id="2-维吉尼亚密码"><a href="#2-维吉尼亚密码" class="headerlink" title="2.维吉尼亚密码"></a>2.维吉尼亚密码</h4><p>维吉尼亚密码便是移位密码的推广</p><script type="math/tex; mode=display">P=C=K=Z_{26}^n\\随机选择密钥k=(k_1,k_2,..,k_n) \in Z_{26}^n \\Enc_k(m_1,m_2,...,m_n)=(m_1+k_1,m_2+k_2,...,m_n+k_n) \\Dec_k(c_1,c_2,...,c_n)=(c_1-k_1,c_2-k_2,...,c_n-k_n)</script><p>实际上就是每个明文加上对应的密钥字。<br>举例如下：若密钥为 $CIPHER$，即 $k=(2,8,15,7,4,17)$<br><img src="https://img-blog.csdnimg.cn/20200216154923425.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>明文是以下字符串：</p><p>$THISCRYPTOSYSTEMISNOTSECURE$</p><p>我们根据字母表将字符串翻译成数字：</p><p>$(19,7,8,18,2,17,24,15,19,14,18,24,18,19,4,12,8,18,13,14,19,18,4,2,20,17,4)$</p><p>然后将其按照密钥个数进行分组，分别与集合 $K$ 相加，得到密钥：</p><p>$(21,15,23,25,6,8,0,23,8,21,22,15,20,1,19,19,12,9,15,22,8,25,8,19,22,25,19)$</p><p>因此密文为：</p><p>$VPXZGIAXIVWPUBTTMJPWIZITWZT$</p><h4 id="3-二维表形式"><a href="#3-二维表形式" class="headerlink" title="3. 二维表形式"></a>3. 二维表形式</h4><p>我们观察到，若密钥为1的话，A将会变成B，若密钥为2的话，A将会变成C，实际上就是字母表整体往左边移动了一个字母和两个字母的距离，我们把移动的26种情况整理下来，变成了一张二维表。<br>其中棕色的行表示明文，橙色的列表示密钥。<br>若密钥为3，实际上对应的字母为C，那么就到C的那一行，可以观察到，A对应的是C，以此类推。因此若想找明文A对应密钥为C的密文，只要找他们的交点即可。以上述例子为例，$THIS$ 的密钥为$(2,8,5,17)$，对应的字母为 $CIPH$，找到 $T$ 和 $C$的交点 $V$，$H$ 和 $I$ 的交点 $P$，$I$ 和 $P$ 的焦点 $X$，$S$ 和 $H$ 的交点 $Z$.因此其密文为 $VPXZ.$<br><img src="https://img-blog.csdnimg.cn/20200216150222284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="维吉尼亚密码二维表"><br>普通的移位密码是通过相同的移位来加密，若明文中有两个相同的字母，例如 $HAPPY$ 的$P$，加密过后仍然会有两个相同的字母，若样本多了之后，就可以根据一些单词的特征进行判断推理进行解密，因此普通的移位加密并不是一种好的加密方法。维吉尼亚密码就可以很好的解决这样的问题。</p><p>下一章将介绍维吉尼亚密码的解密。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;维吉尼亚（Vigenere-Cipher）密码原理介绍&quot;&gt;&lt;a href=&quot;#维吉尼亚（Vigenere-Cipher）密码原理介绍&quot; class=&quot;headerlink&quot; title=&quot;维吉尼亚（Vigenère Cipher）密码原理介绍&quot;&gt;&lt;/a&gt;维吉尼亚（Vigenère Cipher）密码原理介绍&lt;/h2&gt;&lt;h3 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。&lt;br&gt;&amp;emsp;&amp;emsp;维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。&lt;br&gt;&amp;emsp;&amp;emsp;维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”（法语：le chiffre indéchiffrable）。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。&lt;br&gt;来源：&lt;a href=&quot;https://baike.baidu.com/item/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/4905472?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度百科&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200216154546299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="密码学" scheme="http://CherryYang05.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="http://CherryYang05.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="古典密码" scheme="http://CherryYang05.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    
      <category term="维吉尼亚密码" scheme="http://CherryYang05.github.io/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://cherryyang05.github.io/2020/05/04/hello-world/"/>
    <id>http://cherryyang05.github.io/2020/05/04/hello-world/</id>
    <published>2020-05-04T04:10:51.326Z</published>
    <updated>2020-05-06T08:53:41.283Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://CherryYang05.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Test" scheme="http://CherryYang05.github.io/tags/Test/"/>
    
      <category term="demo" scheme="http://CherryYang05.github.io/tags/demo/"/>
    
  </entry>
  
</feed>
