<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>打球只投三分</title>
  
  <subtitle>《上岸》</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cherryyang05.github.io/"/>
  <updated>2021-03-02T13:32:55.832Z</updated>
  <id>http://cherryyang05.github.io/</id>
  
  <author>
    <name>Cherry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博弈论 第1节 导论——五个入门结论</title>
    <link href="http://cherryyang05.github.io/2021/03/01/%E5%8D%9A%E5%BC%88%E8%AE%BA-%E7%AC%AC1%E8%8A%82-%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E4%BA%94%E4%B8%AA%E5%85%A5%E9%97%A8%E7%BB%93%E8%AE%BA/"/>
    <id>http://cherryyang05.github.io/2021/03/01/%E5%8D%9A%E5%BC%88%E8%AE%BA-%E7%AC%AC1%E8%8A%82-%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E4%BA%94%E4%B8%AA%E5%85%A5%E9%97%A8%E7%BB%93%E8%AE%BA/</id>
    <published>2021-03-01T15:49:00.000Z</published>
    <updated>2021-03-02T13:32:55.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博弈论-第1节-导论——五个入门结论"><a href="#博弈论-第1节-导论——五个入门结论" class="headerlink" title="博弈论 第1节 导论——五个入门结论"></a>博弈论 第1节 导论——五个入门结论</h1><h2 id="一、开胃菜——成绩博弈"><a href="#一、开胃菜——成绩博弈" class="headerlink" title="一、开胃菜——成绩博弈"></a>一、开胃菜——成绩博弈</h2><blockquote><p>开场游戏：你和你的同桌在完全不知情的情况下，填写自己的成绩 $α$ 和 $β$，然后老师将所有同学随机分成两两一组，你的成绩将按照以下情况给出：<br>(1)若你填写 $α$ 你的对手填写 $β$，你将得到 $A$ 等级，你的对手将得到 $C$ 等级<br>(2)若你填写 $α$ 你的对手填写 $α$，你将得到 $B-$ 等级，你的对手将得到 $B-$ 等级<br>(3)若你填写 $β$ 你的对手填写 $β$，你将得到 $B+$ 等级，你的对手将得到 $B+$ 等级<br>(4)若你填写 $β$ 你的对手填写 $α$，你将得到 $C$ 等级，你的对手将得到 $A$ 等级</p></blockquote><p>课堂上老师询问了几个选 $α$ 的同学的理由，第一个人觉得对方也会填 $α$，所以我要填 $α$；第二个人的理由是，填 $α$ 的结果总要优于填 $β$.<br>而选择 $β$ 的同学觉得选择 $β$ 成绩波动较小，（会从B+波动到C）（实际上选择 $α$ 波动和 $β$ 一样，从A到B-）；另一个觉得一开始大家可以合作，都填 $β$ 获得最大利益。<br><a id="more"></a><br>目前我们涉及到博弈的<code>行为</code>、<code>策略</code>、<code>参与人</code>，但是忽略了一个博弈的必备要素：<code>动机(objectives)</code>.</p><p>下面我们用效用矩阵表示收益（Possible Payoffs）：</p><table><tr>    <td> 可能情况</td>    <td colspan="2"> Pair <br></td></tr><tr>    <td rowspan="2"> Me <br>    </td><td> α,α</td>    <td> α,β</td></tr><tr>    <td> β,α <br>    </td><td> β,β <br></td></tr></table><table><tr>    <td> 效用 </td>    <td colspan="2"> Pair <br></td></tr><tr>    <td rowspan="2"> Me <br>    </td><td> 0, 0</td>    <td> 3,-1</td></tr><tr>    <td> -1,3 <br>    </td><td> 1, 1 <br></td></tr></table><p>前提是所有人只在乎自己的成绩，并且努力想取得更高的成绩。这里显然能够看出，不管对手选择什么，选择 $α$ 的效益始终大于 $β$ $（0 &gt; -1, 3 &gt; 1）$</p><p>我们称这种始终不会取得劣势的选择称作<code>严格优势策略</code></p><p>因此得到第一个结论：<strong>1.不要选择严格劣势策略</strong>，原因很简单，the payoffs are lower.<br>但似乎这样的结论有些过于简单而不值得讨论。</p><p>但是如若别人也是这样想，选择了 $β$，那么你们都将获得 1 的效用，而 1 是 大于 0 的，因此选择 $β$ 是更好的选择，这似乎与第一个结论有些矛盾。</p><p>实际上这种说法有两个问题，其一，我的想法实际上是无法影响到你的想法，也就是我的选择无法左右你的选择，其二，建立在第一个假设上，若我的想法能够左右你的想法，那么为了争取最大的效用，我应该选择 $α$ 而不是 $β$</p><p>由此得到第二个结论：<strong>2.理性的选择（严格优势策略）往往使得结果变得糟糕</strong><br><code>协商难以达成的原因不是缺少沟通，而是没有强制力</code></p><p>（囚徒困境，三个和尚没水吃，企业价格战）</p><p>换种情况，若效用矩阵变成下面这样：</p><table><tr>    <td> 效用 </td>    <td colspan="2"> Pair <br></td></tr><tr>    <td rowspan="2"> Me <br>    </td><td> 0, 0</td>    <td> -1,-1</td></tr><tr>    <td> -3, 3 <br>    </td><td> 1, 1 <br></td></tr></table><p>若我选择 $α$，而对手选择了 $β$，但是我感到愧疚，良心受到谴责，减去我的负罪感的负效用后只得到了 -1（把他称作负罪感）。相反我选择 $β$，而对手选择了 $α$，觉得不服气只得到了 C，因此下次要好好学习，表现出了雄心壮志，并且这个成绩是因为对手选了 $α$ 所致，在道义上的谴责又减去了一些效用，最终变成了 -3.</p><p>选 $α$ 的人觉得这样可以最小化损失，而选 $β$ 的人觉得这样有机会获得最大效用 1.</p><p>当对方选择 $α$ 时，我应该选择 $α$ 才能获得最大效用，相反，当对方选择 $β$ 时，我也应该选择 $β$ 才能得到最大效用。因此，这种情况下没有严格优势策略，而这也仅仅是改变了博弈的收益，并没有改变博弈的结构和结果，但是我们的目的被改变了。第一种情况我们显然应该选择 $α$，而第二种情况我们却不知道该选什么，这种博弈叫 <strong>协和谬误</strong></p><p>由此得出第三个结论：<strong>3.汝欲得之，必先知之</strong><br><code>永远选择优势策略，损失小，如果对手有优势策略应以此作为选择策略的指导</code></p><p>第三种情况，我们更改<code>对手</code>每种情况的效用，如下：</p><table><tr>    <td> 效用 </td>    <td colspan="2"> Pair <br></td></tr><tr>    <td rowspan="2"> Me <br>    </td><td> 0, 0</td>    <td> 3,-3</td></tr><tr>    <td> -1, -1 <br>    </td><td> 1, 1 <br></td></tr></table><p>显然，$α$ 是严格优势策略，选择 $α$ 更好。</p><p>第四种情况，仅仅修改我自己不同情况下的效用，如下：</p><table><tr>    <td> 效用 </td>    <td colspan="2"> Pair <br></td></tr><tr>    <td rowspan="2"> Me <br>    </td><td> 0, 0</td>    <td> -1,-1</td></tr><tr>    <td> -3, 3 <br>    </td><td> 1, 1 <br></td></tr></table><p>这种情况下，对我自己而言，没有了所谓的严格优势策略，但是对于对手而言，$α$ 是严格优势策略，他必定会选择 $α$，因此我只能选择 $α$ 来获得最大效用。</p><p>因此得到第四个结论：<strong>4.站在对方的立场上去分析对方会怎么做</strong></p><p>综上可以得到第五个结论： <strong>5.人都是自私的</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;博弈论-第1节-导论——五个入门结论&quot;&gt;&lt;a href=&quot;#博弈论-第1节-导论——五个入门结论&quot; class=&quot;headerlink&quot; title=&quot;博弈论 第1节 导论——五个入门结论&quot;&gt;&lt;/a&gt;博弈论 第1节 导论——五个入门结论&lt;/h1&gt;&lt;h2 id=&quot;一、开胃菜——成绩博弈&quot;&gt;&lt;a href=&quot;#一、开胃菜——成绩博弈&quot; class=&quot;headerlink&quot; title=&quot;一、开胃菜——成绩博弈&quot;&gt;&lt;/a&gt;一、开胃菜——成绩博弈&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;开场游戏：你和你的同桌在完全不知情的情况下，填写自己的成绩 $α$ 和 $β$，然后老师将所有同学随机分成两两一组，你的成绩将按照以下情况给出：&lt;br&gt;(1)若你填写 $α$ 你的对手填写 $β$，你将得到 $A$ 等级，你的对手将得到 $C$ 等级&lt;br&gt;(2)若你填写 $α$ 你的对手填写 $α$，你将得到 $B-$ 等级，你的对手将得到 $B-$ 等级&lt;br&gt;(3)若你填写 $β$ 你的对手填写 $β$，你将得到 $B+$ 等级，你的对手将得到 $B+$ 等级&lt;br&gt;(4)若你填写 $β$ 你的对手填写 $α$，你将得到 $C$ 等级，你的对手将得到 $A$ 等级&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;课堂上老师询问了几个选 $α$ 的同学的理由，第一个人觉得对方也会填 $α$，所以我要填 $α$；第二个人的理由是，填 $α$ 的结果总要优于填 $β$.&lt;br&gt;而选择 $β$ 的同学觉得选择 $β$ 成绩波动较小，（会从B+波动到C）（实际上选择 $α$ 波动和 $β$ 一样，从A到B-）；另一个觉得一开始大家可以合作，都填 $β$ 获得最大利益。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="博弈论" scheme="http://CherryYang05.github.io/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    
      <category term="导论" scheme="http://CherryYang05.github.io/tags/%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>TFTP简单文本传输协议的基本原理</title>
    <link href="http://cherryyang05.github.io/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://cherryyang05.github.io/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-10T11:32:31.000Z</published>
    <updated>2021-02-16T13:55:51.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TFTP简单文本传输协议的介绍"><a href="#TFTP简单文本传输协议的介绍" class="headerlink" title="TFTP简单文本传输协议的介绍"></a>TFTP简单文本传输协议的介绍</h2><p>随着互联网发展，文件传输效率越来越快，相应的传输协议也越来越复杂。早年有很多文件传输协议如今已经很少再用，所谓老兵不死，只是慢慢凋零。这些协议尽管现在使用不多，但它们的设计思想依然值得我们好好研究和掌握。</p><p>例如 FTP 以及它的 UDP 版本 TFTP，它们实现文件传输的协议设计思想依然非常值得研究，它对我们设计新协议依然很有启发性。本节开始，我们研究 TFTP 协议的原理以及相关代码实现。</p><p>TFTP 原名叫<code>Trivial File Transport Protocol</code>.对互联网早期存有记忆的同学对 FTP 协议一定非常了解，当时局域网乃至整个网络上很多大文件，例如电影的传输依靠的就是该协议。FTP 协议运行在 TCP 协议之上，它的内容很复杂，除了文件传输外，它还支持很多文件相关操作，例如远程实现文件建立，删除等。TFTP 是 FTP 协议的简化版，它运行在 UDP 协议上，同时简化了很多 FTP 操作，只支持文件的传输功能。<br><a id="more"></a><br>TFTP协议是基于服务器和客户端之间的传输协议。一开始客户端向服务器发出连接请求，服务器应答后两者连接建立。然后客户端向服务器发出文件传输请求，服务器将客户端需要的文件分割成多个小块，依次传递给客户端，客户端每收到一个小块后向服务器发出应答，收到应答后服务器再发送下一个小块。当所有文件块传输完毕后，两者连接断开。</p><p>TFTP 服务器程序通常在端口 69 监听客户端请求。值得注意的是，当服务器与客户端进行数据块传输时，服务器会使用一个随机端口而不是用于监听请求的 69 端口，这是为了服务器能同时相应多个客户端的连接。服务器与不同客户端使用不同端口进行数据通信，这样就保证不同客户端所需要的数据块不会发生混淆。</p><p>服务器与客户端在发送文件数据时，会按照一种名为”锁定步骤”的方式进行数据传输。也就是服务器向客户端发送一个数据块，再接收到客户端发回的应答数据包前什么都不做，直到收到客户端确定数据块已经收到的应答后，它才发送下一个数据块，这种方式使得数据传输效率不高，但确保数据传输流程足够简单，同时能保证传输出错时，数据重传很方便，同时客户端也不用考虑数据块不按次序抵达时，如何将数据块进行正确组装。</p><p>TFTP 协议的简单附带的代价是效率不高。由于它走的是 UDP 协议，因此一次发送数据块不能超过 512 字节，这也是服务器必须把文件切成小块反复传输的原因。还有一点值得注意的是 TFTP 协议没有任何安全措施，它不需要注册或登录，任何客户端都可以连接然后下载文件。</p><p>我们首先在网络上下载一个 TFTP 的服务器客户端：<a href="http://tftpd32.jounin.net/tftpd32_download.html">Tftpd64</a> 具体界面如下：</p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/tftpd64.png" alt="tftpd64"></p><p>然后在 Windows 中的设置的程序与功能中打开 TFTP Client:</p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/tftp_Windows.png" alt="tftp_Windows"></p><h2 id="TFTP抓包演示"><a href="#TFTP抓包演示" class="headerlink" title="TFTP抓包演示"></a>TFTP抓包演示</h2><p>我们在 TFTP 服务器客户端上选择我们的 IP 地址：192.168.1.101，然后这台电脑就可以作为我们的 TFTP 服务器了，然后我们在命令行中输入：<code>tftp 192.168.1.101 get test.txt</code>(test.txt 是我特地新建的用来测试的文件，该文件必须存放在 tftp 服务器客户端软件中 Current Directory 所显示的目录中)：</p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/tftp抓包1.png" alt="tftp抓包1"></p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/tftp抓包2.png" alt="tftp抓包2"></p><p>然后就可以在当前磁盘（G盘）中看到我们传送的文件了</p><p>需要注意的几个问题:</p><ol><li>文件传送成功与否，你朋友也可以在 Tftpd32 的 “Tftp Server” 和 “Current Action”这两项中看到。</li><li>如果想把文件传给你朋友，那么只要把命令换成 “Tftp -i朋友IP put pictures.rar” 即可。关于Tftp命令的更多参数，你可以在 CMD 下输入 Tftp 进行查看。不过此时你朋友不能进行上传和下载工作，因为他此时是 Tftp 的服务端，只有客户端才能进行这些操作。如果他想把西传给你，那就需要你做服务端了。</li><li>用 Tftp 传送文件时，服务端需有确定的公网 IP，如果你朋友在局域网中通过网关上网的话，那就无法传送了。当然，如果两个人在同一局域网中，内网的 IP 也可以传送文件,只是有些多此一举。</li><li>Windows 98 系统可以当服务端，但客户端一定要是 Windows 2000 或是 Windows XP 等有 Tftp 命令的系统。<br>以后如果你遇到因为防火墙等原因不能通过QQ传送文件时，不妨试试 Tftp.</li></ol><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/tftp抓包3.png" alt="tftp抓包3"></p><p>我们再通过 Wireshark 抓包来观察 TFTP 协议(由于在 Windows上自己传给自己抓不到包，因此我在 Linux虚拟机上进行测试)，但是出现了 <code>Destination unreachable (Host administratively prohibited)</code>，查询资料得知，是 Linux 的防火墙没有设置，我们设置一下 iptables:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -P OUTPUT ACCEPT       <span class="comment">#允许所有本机向外的访问</span></span><br><span class="line">iptables -P FORWARD ACCEPT      <span class="comment">#允许所有转发</span></span><br><span class="line">iptables -P INPUT ACCEPT        <span class="comment">#允许所有本机向外的访问</span></span><br><span class="line">iptables -F                     <span class="comment">#清除所有规则</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/tftp抓包4.png" alt="tftp抓包4"></p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/tftp抓包5.png" alt="tftp抓包5"></p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/tftp抓包6.png" alt="tftp抓包6"></p><p>【注】:我的电脑不知道为何只能抓到单向的数据包，无法抓到主机向虚拟机传送的数据包，查了很多资料之后未果，先接着学习吧。</p><p>抓包显示两种数据包，分别是 Acknowledgement 和 Data block，其中前者是客户端收到数据块后对服务器的应答，后者是服务器向客户端发送的数据块。数据包的具体格式我们会在后面进行详细分析。</p><h2 id="TFTP交互细节及数据包解读"><a href="#TFTP交互细节及数据包解读" class="headerlink" title="TFTP交互细节及数据包解读"></a>TFTP交互细节及数据包解读</h2><p>tftp 主要分为三步，首先是连接，然后是数据传输，最后是连接中断。所有这些步骤都通过发送相关数据包完成。最开始由客户端发送一个数据读取或写入请求，这个请求发出的同时连接自动建立，在这个过程中双方会协议要传输什么格式的文件。TFTP协议支持两个格式文件的传输，分别是 ASCII 文本，另一种是二进制数据，FTP 协议支持的文本格式比 TFTP 要复杂得多。</p><p>如果客户端请求的文件存在，服务器会直接将第一个数据块发送给客户端。如果是客户端想上传文件，服务器会发送一个 ACK 数据包表示确认。在这个过程中如果出现错误，其中一方就向另一方发送错误信息数据包，然后文件传输终止。由于使用 UDP 作为底层协议，因此一次数据发送最大不超过 <code>512</code> 字节。因此为了保证数据顺序正确性，每个数据包必须对应相应编号，编号根据数据块的顺序从1开始。</p><p>由于每次数据块最大是 512 字节，只要文件传输没有结束，那么一次数据块就是 512 字节，如果有数据包中数据少于 512 字节，那意味着这是文件最后一个数据包，最后一个数据块发送完后，连接自动中断。我们通过一个具体实例来掌握数据发送流程，假设客户端想从服务器读取一个 1200 字节的文件，以下是相关步骤：</p><ol><li>客户端发送一个数据包给服务器，其中包含了要读取的文件名。</li><li>服务器发回第一个 512 字节数据块，并对其标号为 1.</li><li>客户端返回服务器一个标号为 1 的确认数据包</li><li>服务器发送标号为 2 包含 512 字节的数据块</li><li>客户端收到 2 号数据块后发生确认数据包</li><li>服务器发送标号为 3 的包含 176 字节的数据块</li><li>客户端收到后回发标号为 3 的确认数据包</li><li>服务器收到确认数据包后，确认文件发送完毕</li></ol><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/传输示例.png" alt="传输示例"></p><p>我们再看看客户端上传文件的流程：</p><ol><li>客户端发送一个写请求数据包，里面包含了要写的文件名称</li><li>服务器发送确认数据包，在数据包中它使用编号 0</li><li>客户端发送一个含有 512 字节，编号为1的数据包</li><li>服务器返回编号为 1 的确认数据包</li><li>客户端发送编号为 2，包含 512 字节的数据包</li><li>服务器返回编号为 2 的确认数据包</li><li>客户端发送编号为 3，包含 176 字节的数据包，等待服务器返回确认数据包。</li><li>服务器接受 3 号数据包后，返回确认数据包，由于该数据包数据少于 512 字节，服务器知道是最后一个数据包。</li><li>客户端收到 3 号确认数据包后，知道文件传输完毕，中断连接。</li></ol><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/传输示例2.png" alt="传输示例2"></p><p>TFTP 协议后来又经过一次扩展，增加一些控制命令。如果客户端或服务器想使用扩展命令时，它必须向对方确认是否也能支持相应命令。它会发送一个数据包，里面包含扩展命令对应的数值列表，对方也会返回一个列表，把它支持的扩展命令对应的数值放在列表中，不支持的则不在列表里。TFTP 协议一个特点是，它不允许任何一方连续发送 2 个数据包，必须是<code>一来一回</code>。具体的扩展功能在协议实现时我们再详细研究。</p><h2 id="探究数据包具体格式"><a href="#探究数据包具体格式" class="headerlink" title="探究数据包具体格式"></a>探究数据包具体格式</h2><p>我们看看 TFTP 数据包的组装方式，为我们代码实现该协议奠定基础。TFTP 协议总共有5种不同数据包，分别对应读请求，写请求，数据块，接收回应(ACK)，以及错误。前两种数据包格式一样，只不过某些值域设置有差别，剩下的三种数据包格式各不相同。但无论哪一种数据包，他们都包含一个值域叫操作码，用来定义该数据包属于那种类型。</p><p>我们先看读请求和写请求数据包的格式，首先是2字节表示操作码，它用来表示当前数据包的类型，取值 1 表示该数据包是个读请求，2 表示该数据包是；接下来是可变长字段，它用来表示要读取或上传的文件名，它使用 ASCII 码并以 0 表示结尾；第三个字段叫 Mode，也是可变长字段，用来表示传输文件的数据类型，如果传输的是字符串文件，那么它填写字符串 “netascii”，如果传输的是二进制文件，那么它填写字符串 “octet”，这些字符串都以 0 结尾，其结构用下图表示：</p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/读写请求数据包.png" alt="读写请求数据包"></p><p>接着我们看看传输数据块的数据包，它的前 2 字节也是操作码，取值 3 用于表示数据包用于数据块传输，接下来是 2 字节，用于表示数据块编号，最后是可变长字段 Data，用于装载数据块，该数据包的格式如下：</p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/传输数据块数据包.png" alt="传输数据块数据包"></p><p>然后是应答数据包，它开始 2 字节也是操作码，取值 4，接下来2字节表示接收到的数据块编号，相应结构如下图：</p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/应答数据包.png" alt="应答数据包"></p><p>最后一个是错误数据报，它前 2 字节表示操作码，取值 5；接下来 2 字节表示错误码，0 表示未知错误，1 表示文件不存在，2 表示权限不足，3 表示磁盘已满，具体的错误码我们在实践时再具体分析；接下来是可变长字段，它用字符串的形式描述具体错误，该数据包的结构如下图：</p><p><img src="/2020/06/10/TFTP%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/错误数据包.png" alt="错误数据包"></p><h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TFTP简单文本传输协议的介绍&quot;&gt;&lt;a href=&quot;#TFTP简单文本传输协议的介绍&quot; class=&quot;headerlink&quot; title=&quot;TFTP简单文本传输协议的介绍&quot;&gt;&lt;/a&gt;TFTP简单文本传输协议的介绍&lt;/h2&gt;&lt;p&gt;随着互联网发展，文件传输效率越来越快，相应的传输协议也越来越复杂。早年有很多文件传输协议如今已经很少再用，所谓老兵不死，只是慢慢凋零。这些协议尽管现在使用不多，但它们的设计思想依然值得我们好好研究和掌握。&lt;/p&gt;
&lt;p&gt;例如 FTP 以及它的 UDP 版本 TFTP，它们实现文件传输的协议设计思想依然非常值得研究，它对我们设计新协议依然很有启发性。本节开始，我们研究 TFTP 协议的原理以及相关代码实现。&lt;/p&gt;
&lt;p&gt;TFTP 原名叫&lt;code&gt;Trivial File Transport Protocol&lt;/code&gt;.对互联网早期存有记忆的同学对 FTP 协议一定非常了解，当时局域网乃至整个网络上很多大文件，例如电影的传输依靠的就是该协议。FTP 协议运行在 TCP 协议之上，它的内容很复杂，除了文件传输外，它还支持很多文件相关操作，例如远程实现文件建立，删除等。TFTP 是 FTP 协议的简化版，它运行在 UDP 协议上，同时简化了很多 FTP 操作，只支持文件的传输功能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://CherryYang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP协议" scheme="http://CherryYang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="计算机网络" scheme="http://CherryYang05.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TFTP协议" scheme="http://CherryYang05.github.io/tags/TFTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>DNS协议原理实现</title>
    <link href="http://cherryyang05.github.io/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
    <id>http://cherryyang05.github.io/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-05-27T07:21:23.000Z</published>
    <updated>2021-02-16T14:28:09.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS-域名解析协议-基本原理介绍"><a href="#DNS-域名解析协议-基本原理介绍" class="headerlink" title="DNS(域名解析协议)基本原理介绍"></a>DNS(域名解析协议)基本原理介绍</h2><p>我们这章开始研究和实现一个体系较为复杂的协议，也就是域名解析协议，简写为DNS。该协议几乎也是我们”日用而不知”的幕后英雄，没有它肯定就没有现在的互联网繁荣。</p><p>当我们在浏览器上输入网址，例如<code>www.baidu.com</code>时，浏览器先通过DNS协议找到与该网址对应的IP地址，然后再使用IP去向服务器获取网页信息。也就是说互联网上的设备其实有两种辨认方法，一种是IP，一种是域名。就如同人的身份证，人有名字，同时也有几十位数字组成的身份证号。</p><p>人与人相互识别时，使用的都是名字，几乎没有人使用身份证号来识别他人的，即使身份证号相对于名字而言更加唯一和准确。说到底是因为人对数字识别很费劲，而记住名字很容易。<br><a id="more"></a><br>对计算机的访问也是如此。在互联网发展早期，计算机只是在局域网内互联，并且联网的机器非常有限，因此当时使用IP直接定位不同的机器。但是随着网络的发展，联网的机器越来越多，使用数字辨别每一台计算机变得越来越困难，于是人们开始想用更方便的记忆方式，于是自然就想到用字符串来替代难以记忆的数字。</p><p>然而对程序而言，它只能识别数字，于是字符串仅仅用作于方便记忆，在运行机制上，程序就得把字符串与IP数字进行转换。最早使用的转换机制很简单，甚至到现在还在使用，那就是hosts文件，它使用文本的方式将IP与字符串名字对应起来，如下图：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/host.png" alt="host"></p><p>程序在运行时，先将该文件内容读入内存，当用户输入网址时，它先从里面的对应关系中，将网址直接转换成对应的IP地址。这种方法在主机数量少时适用，但现在网络上的主机数量数以千万计，如此我们得在文件中维护几万个对应关系，这显然不合情理，随着联网的设备越来越多，适用这种静态配置的方式越来越不合时宜，因此全网使用一种统一的IP字符串映射方式是势在必行。</p><p>如今能满足这种域名转换成IP需要机制，就是我们要研究和实现的DNS协议，它是极佳的分布式系统设计案例，互联网发展几十年来，接入网络的设备呈指数级增长，需要进行域名解析的请求自然也指数级增长，DNS自设计完成以来就具备了极佳的扩展性，因此它在没有大变动的情况下，满足日益增长的需求，可见其设计思路之巧妙。</p><h3 id="DNS协议系统"><a href="#DNS协议系统" class="headerlink" title="DNS协议系统"></a>DNS协议系统</h3><p>相比于其他网络协议，DNS协议本身更像是一个系统。它主要包含以下三种系统功能：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/DNS协议.png" alt="DNS协议"></p><p>显然我们不可能实现全部功能，但我们会选择一些重要模块进行研究和实现，事实上抓住局部原理，对整体功能的把握也就能做到心中有数。DNS分为三大块，紫色部分是名字空间，它规定了域名的层级构造标准，第二部分是名字注册，它负责添加新设备的名称并防止名字冲突，第三部分是名字解析，它负责将域名转换为对应IP。</p><p>在了解DNS协议时，我们需要掌握一个很重要的概念叫域名。”域名”其实是对一个特定领域的统一称呼。例如我的大学名叫”北京化工大学”，于是对于我母校而言，它是一级域名，在下面又分很多个学院，例如理学院，化工学院，文法学院等，这些学院名称就是二级”域名”，学院内又有很多个系，像我所在的理学院有：数学系，物理系，化工系，这些系的名称就是三级域名，系下面又分班，比如我所在的数学系分为1，2，3，4班，这四个班名称对应的是四级域名，每个班内的人都有自己的名字，于是就对应五级域名。</p><h3 id="DNS域名结构"><a href="#DNS域名结构" class="headerlink" title="DNS域名结构"></a>DNS域名结构</h3><p>DNS中的域名以拓扑树的方式存在，如下图：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/DNS域名.png" alt="DNS域名"></p><p>它以一个根节点开始，派生出一级域名，一级域名下面是二级域名，二级域名之后全都叫子域名。每一级域名可以使用数字和字符组合成的字符串来表示，其中字符串不区分大小写，同时一个域名下面的子域名不能相同，假设有一个一级域名叫<code>Black</code>,那么它下层的子域名可以是<code>white</code>，但必须只有一个，如果有另一个子域名叫<code>WHITE</code>，由于域名不区分大小写，因此两个域名被认为相同，这是不允许的。</p><p>由此域名设定时可以从根到叶子节点，中间以符号<code>.</code>隔开。上图中的Root始终对应空字符串，所以<code>www.baidu.com</code>对应于上图而言，第一级域名就是<code>com</code>，第二级域名就是<code>baidu</code>，第三级域名就是<code>www</code>，在解析的时候，该字符串域名就要倒转变成<code>www.baidu.com</code>。如果是百度知道，那么域名就是<code>zhidao.baidu.com</code>.</p><p>一级域名由特定机构控制例如IANA这类互联网管理机构，而二级域名往往对应一个特定组织或团体，例如baidu对应百度公司，三级域名则由组织自己控制。域名对公司而言是非常重要的信息资产，早期有很多聪明人通过域名碰瓷，也就曾大公司或机构不注意，用他们的名字注册域名，结果这些公司想用时只能从他们手中高价购买，很多人就靠这种手段发了大财。</p><h3 id="域名解析流程"><a href="#域名解析流程" class="headerlink" title="域名解析流程"></a>域名解析流程</h3><p>接下来我们看看域名解析的基本流程。首先要解析域名，我们先找到含有相关域名信息的服务器，然后向该服务器发送信息请求。问题在于，域名信息不是存储在固定服务器中，为了系统鲁棒性和扩展性，域名信息以分布式的形式存储在不同服务器里，因此第一步要查询哪个服务器包含了域名对应的信息。</p><p>假设我们要解析域名<code>C.B.A</code>，首先我们将请求发送给所谓的根域名服务器，该服务器会把拥有域名A的服务器地址返回给我们，返回的服务器可能知道域名B.A的信息或者它把关于A的信息返回后，再给我们一个知道域名B的服务器地址，返回的服务器可能知道域名C的信息，或者返回域名B的信息后，再告诉我们哪个服务器知道域名C的信息，因此我们在解析过程中要根据服务器返回信息进行选择。</p><h2 id="DNS协议系统运行流程及数据包解析"><a href="#DNS协议系统运行流程及数据包解析" class="headerlink" title="DNS协议系统运行流程及数据包解析"></a>DNS协议系统运行流程及数据包解析</h2><h3 id="域名信息存储"><a href="#域名信息存储" class="headerlink" title="域名信息存储"></a>域名信息存储</h3><p>DNS协议的运转需要客户端和服务器进行交互。由于服务器端需要存储大量的域名信息，同时每天需要应答海量的解析请求，因此它的设计必须遵循<code>分布式系统</code>。客户端向一台服务器请求解析服务时，对方可能没有相应的域名信息，于是它会向上一层查询，获得拥有给定域名信息的服务器，然后把对应服务器的信息归还给客户端，然后客户端再重新发起请求。</p><p>我们还需要关注域名信息如何在服务器上存储。在域名服务器上，信息存储有两种方式，一种是域名信息以二进制格式存储，这种格式对应的名称叫<code>Resource Record Filed Format</code>，同时为了方便管理员管理，这些信息又通过文本形式展现出来，对应的格式称为<code>Master File Representation</code>,管理员通过修改后者就能使得对应的二进制信息进行相应变换：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/域名信息存储.png" alt="域名信息存储"></p><p>Resource Record 是一种特定数据结构，专门用于存储域名解析相关信息，例如域名对应的服务器IP，域名解析服务器地址等，在后面我们解析数据包时再深入探讨。</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>域名解析其实有三种形式：</p><ul><li>第一种是我们熟悉的，将域名发给服务器然后获得域名对应IP；</li><li>第二种叫反向解析，将IP发给服务器然后获得对应域名；</li><li>第三种叫电子邮件解析，将邮件地址发给服务器然后获得邮件的接收对象IP.</li></ul><p>我们将主要关注第一种形式的原理和实现。</p><p>当我们执行第一种域名解析时，首先要做的是获得域名服务器地址。这个过程并非一撮而就，有可能我们查询第一个服务器时，它给我们返回另一个服务器的地址，然后我们继续查询；第二步是确定服务器后，我们要解析它返回来的数据内容。在这个过程中，第二步相对容易，而第一步则比较棘手。</p><p>在查询对应域名服务器时有两种方式，一种是<code>循环式</code>，第一个域名没有对应信息，但返回另一个它认为有对应信息的服务器，接着客户端向第二个服务器请求，第二个服务器又返回另一个服务器信息，该过程依次循环直到找到对应服务器为止：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/域名解析：循环式.png" alt="域名解析：循环式"></p><p>第二种叫<code>递归式</code>，它与一种的区别在于，服务器承担起客户端查找对应服务器的职责，服务器会反复向其他服务器查询，直到拿到对应域名信息后，直接返回给客户端：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/域名解析：递归式.png" alt="域名解析：递归式"></p><p>一般担任root服务器的角色的是路由器</p><h3 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h3><p>接下来我们看看DNS数据包的基本格式，首先第一部分叫<code>Header</code>，用于描述消息类型，以及后续数据结构的相关信息；第二部分叫<code>Question</code>，它用来包含客户端想向服务器查询的信息；第三部分叫<code>Answer</code>，是服务器用于回复客户端查询；第四部分叫<code>Authority</code>，如果请求没有得到全部答复，这部分内容告诉客户端向哪个服务器进行查询；第五部分叫<code>Additional</code>，这部分包含客户端查询信息的附加说明，它并非必须，所以数据包的基本结构如下：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/DNS数据包.png" alt="DNS数据包"></p><p>我们用wireshark抓取DNS有关的消息包后，对照上面描述的条目进行解析。启动wireshark，然后使用关键词DNS过滤，然后在浏览器里输入一个你以前没有访问过的网址，如果输入已经访问过的，浏览器会有缓存，因此不会走dns协议。以下是我抓取到的一个DNS解析请求包：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/DNS数据包格式.png" alt="DNS数据包具体格式(查询)"></p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/DNS数据包格式（回复）.png" alt="DNS数据包格式（回复）"></p><p>首先是头部，它包含12字节，从<code>Transaction ID</code> 到 <code>Additional RRs</code>，每个字段2字节。ID用来标志一次会话，一个会话内的数据包拥有相同ID。Flags分为两部分，第一部分一字节叫做<code>QR(query &amp; response)</code>，用来表示该数据包是查询还是回答，如果是查询就设置为0，如果是回答就设置为1.如果是查询，那么第二个字节就是OpCode，进一步表明具体查询，它分为若干部分，前四个比特位用于表明查询类型，0表示查询域名对应IP，1不再使用；2表示查询域名服务器状态；3目前不使用，4用于服务器之间的交互；5也是用于服务器之间的交互。</p><p>第五个比特位叫<code>AA(Authoritative)</code>,它只在回复包中设置，用于表明回复的权威性，只有在最后能够获得完整的IP的服务器上，才会返回1，其他中间的服务器只是起到代理作用，返回0.第六个比特位叫<code>TC(Truncated)</code>，它用于表明数据是否被截断，用于DNS支持UDP和TCP，但使用UDP时数据包不能超过512字节，如果超过数据包就得截断成多个小数据包，如果该位设置成1，它表明双方需要通过TCP来建立连接。第八位叫<code>RD(Recursion desired)</code>，如果设置成1，它意味着客户端<code>请求递归式查询</code>，也就是让服务器帮忙向其他服务器询问，得到最终消息后再返还给客户端。<strong>根据此比特位可以判断下面的信息是不是最终信息，如果该比特位为0，那么还需要根据下面的信息解析其他服务器传递过来的内容。</strong></p><p>接下来字节的比特位是<code>RA</code>，如果设置为1表示服务器支持递归式查询，也就是服务器把所有累活都承担了，0则是不支持。接下来三个比特位必须设置为0，接着4个比特位表示返回码，如果值为0表示返回数据正常，非0表示出现错误，其中取值1表示查询数据包格式错误；2表示服务器自身故障；3表示解析错误；4表示不支持所要求的查询；5表示拒绝查询请求；其他值我们暂时忽略。</p><p>接下来用于表示相应条目的数量，<code>Questions</code>表示有几个查询条目，<code>Answer RRs</code>表示有几个回复条目，<code>Authority RRs</code>表示有几个权威信息条目，所谓”权威”是指真正能够解析域名的服务器，如果当前服务器不能解析域名请求，它需要把请求转发给其他服务器时，它自己就不是Authoritive，我们家用路由器其实承担域名解析服务器的职责，但是它本身不可能包含所需要的域名信息，它会把请求转发给上一层服务器，因此路由器就不是”权威”域名解析服务器。由此一个DNS域名解析数据包的轮廓如下：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/DNS域名解析数据包.png" alt="DNS域名解析数据包"></p><p>返回的问题段的数据结构：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/Answer段数据结构.png" alt="问题段数据结构"></p><p>数据包：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/Answer段数据包.png" alt="答案段数据包"></p><p>首先是答案名字，这个字段长度可变，存储的是要查询的域名，以00作为结尾。第二个是问题类型(Type)，它是2字节，用于表明查询的类型，取值1表示查询域名对应IP，取值2查询服务器名称，具体类型在后面我们用到时再详细讨论。最后是问题类别，一般而言写死为1(IN,表明查询媒介类型为因特网)。</p><p>这里我们讲解一下查询的域名(Queries Name)对应的字符串结构，例如对于字符串：www.baidu.com，它的对应格式为<code>[3]www[5]baidu[3]com</code>,其中[]内表示接下来字符个数，例如[3]表示后面跟着3个字符www,[5]表示接下来跟着5个字符，<strong>注意到这些数字所在位置正好对应字符串中符号点所在位置。</strong> 最后以<code>00</code>结尾。</p><p>接下来我们看<code>Answer Resource Records</code>的结构，服务器收到客户端请求，完成解析工作后，把解析信息存储在该结构里发回给客户端。它的结构如下，第一个是名字字符串，可变长，它对应要解析的域名或服务器名称。接着是资源类型，2字节，表明资源的类型，如果取值是5，那么接下来对应着域名服务器对应的字符串名称，接着是资源类别，2字节，一般设置成1；接着是TTL(Time To Live)，4字节，表明这些信息能在缓存中存储多久；接着是RDLength，2字节，用于表明接下来内容的长度；最后是相应内容，如果资源类型是5，那么内容就是字符串，如果是1，那么内容就是4字节的IP地址，该数据类型对应的格式轮廓如下：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/Answer段完整数据结构.png" alt="答案段完整数据结构"></p><p>这里值得提到的是，如果资源类型5，那么对应的字符串才是”真正”域名，例如下面显示内容：</p><p><img src="/2020/05/27/DNS%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/资源类型5.png" alt="资源类型5"></p><p>它显示的是，一开始我们使用域名<code>pan.baidu.com</code>去进行域名解析，此时解析服务器没有直接返回该域名对应的IP，而是返回另一个域名<code>yiyun.n.shifen.com</code>，前面<code>pan.baidu.com</code>其实是一个别名，打个比方，一个人可以使用假名和真名，假名可以随时变，真名则要跟身份证绑定。同样的道理，<code>pan.baidu.com</code>这个域名可以根据需要随时变化，例如以后它可以变成<code>pen.baidu.com</code>，但是第二个域名就唯一绑定一台服务器，我们只有拿这个域名去查询才能找到对应的IP。</p><p>为了简单起见，其他两种资源的数据格式我们暂时放一放，以后需要的时候才研究，在下一节我们将使用代码实现本节描述的DNS域名解析流程。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> protocol.IProtocol;</span><br><span class="line"><span class="keyword">import</span> protocol.ProtocolManager;</span><br><span class="line"><span class="keyword">import</span> protocol.UDPProtocolLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Cherry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span> 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Brief</span> DNS 域名解析协议</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DNSApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] resolve_server_ip = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String domainName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] dnsHeader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] dnsQuestion = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> transition_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> QUESTION_TYPE_LENGTH = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> QUESTION_CLASS_LENGTH = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">short</span> QUESTION_TYPE_A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">short</span> QUESTION_CLASS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> DNS_SERVER_PORT = <span class="number">53</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该类型表示服务器返回域名的类型号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">short</span> DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">short</span> DNS_ANSWER_HOST_ADDRESS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化，一般将域名交给路由器让其查询IP</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destIP     要查询域名的服务器IP，一般为该局域网的路由器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> domainName 域名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DNSApplication</span><span class="params">(<span class="keyword">byte</span>[] destIP, String domainName)</span> </span>&#123;</span><br><span class="line">        resolve_server_ip = destIP;</span><br><span class="line">        <span class="keyword">this</span>.domainName = domainName;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        transition_id = (<span class="keyword">short</span>) random.nextInt();</span><br><span class="line">        <span class="comment">//随机选择一个发送端口，这个没有具体要求</span></span><br><span class="line">        <span class="keyword">this</span>.port = (<span class="keyword">short</span>) random.nextInt();</span><br><span class="line">        constructDNSPacketHeader();</span><br><span class="line">        constructDNSPacketQuestion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组装 DNS 首部，12B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">constructDNSPacketHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">12</span>];</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(header);</span><br><span class="line">        <span class="comment">//会话Id,2B</span></span><br><span class="line">        buffer.putShort(transition_id);</span><br><span class="line">        <span class="comment">//2字节操作码</span></span><br><span class="line">        <span class="keyword">short</span> opCode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果是查询数据包，第16个比特位要将最低位设置为0,接下来的4个比特位表示查询类型，如果是查询ip则设置为0，</span></span><br><span class="line"><span class="comment">         * 第11个比特位由服务器在回复数据包中设置，用于表明信息是它拥有的还是从其他服务器查询而来，</span></span><br><span class="line"><span class="comment">         * 第10个比特位表示消息是否有分割，有的话设置为1，由于我们使用UDP，因此消息不会有分割。</span></span><br><span class="line"><span class="comment">         * 第9个比特位表示是否使用递归式查询请求，我们设置成1表示使用递归式查询,</span></span><br><span class="line"><span class="comment">         * 第8个比特位由服务器返回时设置，表示它是否接受递归式查询</span></span><br><span class="line"><span class="comment">         * 第7,6,5，3个比特位必须保留为0，</span></span><br><span class="line"><span class="comment">         * 最后四个比特由服务器回复数据包设置，0表示正常返回数据，1表示请求数据格式错误，2表示服务器出问题，3表示不存在给定域名等等</span></span><br><span class="line"><span class="comment">         * 我们发送数据包时只要将第9个比特位设置成1即可(从1开始向左数第9位)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        opCode = (<span class="keyword">short</span>) (opCode | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>));</span><br><span class="line">        buffer.putShort(opCode);</span><br><span class="line">        <span class="comment">//接下来是2字节的question count,由于我们只有1个请求，因此它设置成1</span></span><br><span class="line">        <span class="keyword">short</span> questionCount = <span class="number">1</span>;</span><br><span class="line">        buffer.putShort(questionCount);</span><br><span class="line">        <span class="comment">//剩下的默认设置成0</span></span><br><span class="line">        <span class="keyword">short</span> answerRRCount = <span class="number">0</span>;</span><br><span class="line">        buffer.putShort(answerRRCount);</span><br><span class="line">        <span class="keyword">short</span> authorityRRCount = <span class="number">0</span>;</span><br><span class="line">        buffer.putShort(authorityRRCount);</span><br><span class="line">        <span class="keyword">short</span> additionalRRCount = <span class="number">0</span>;</span><br><span class="line">        buffer.putShort(additionalRRCount);</span><br><span class="line">        <span class="keyword">this</span>.dnsHeader = buffer.array();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造DNS数据包中包含域名的查询数据结构</span></span><br><span class="line"><span class="comment">     * 首先是要查询的域名，它的结构是是：字符个数+是对应字符，</span></span><br><span class="line"><span class="comment">     * 例如域名字符串pan.baidu.com对应的内容为</span></span><br><span class="line"><span class="comment">     * [3]pan[5]baidu[3]com也就是把 &#x27;.&#x27;换成它后面跟着的字母个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">constructDNSPacketQuestion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//解析域名结构，按照 &#x27;.&#x27; 进行分解,第一个1用于记录&quot;pan&quot;的长度，第二个1用0表示字符串结束</span></span><br><span class="line">        dnsQuestion = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> + <span class="number">1</span> + domainName.length() + QUESTION_TYPE_LENGTH + QUESTION_CLASS_LENGTH];</span><br><span class="line">        String[] domain = domainName.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(dnsQuestion);</span><br><span class="line">        <span class="keyword">for</span> (String str : domain) &#123;</span><br><span class="line">            <span class="comment">//先填写字符个数</span></span><br><span class="line">            buffer.put((<span class="keyword">byte</span>) str.length());</span><br><span class="line">            <span class="comment">//填写字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line">                buffer.put((<span class="keyword">byte</span>) str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用0表示域名表示结束</span></span><br><span class="line">        <span class="keyword">byte</span> end = <span class="number">0</span>;</span><br><span class="line">        buffer.put(end);</span><br><span class="line">        <span class="comment">//填写查询问题的类型和级别</span></span><br><span class="line">        buffer.putShort(QUESTION_TYPE_A);</span><br><span class="line">        buffer.putShort(QUESTION_CLASS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向服务器发送查询请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryDomain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] dnsPacketBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[dnsHeader.length + dnsQuestion.length];</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(dnsPacketBuffer);</span><br><span class="line">        buffer.put(dnsHeader);</span><br><span class="line">        buffer.put(dnsQuestion);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] udpHeader = createUDPHeader(dnsPacketBuffer);</span><br><span class="line">        <span class="keyword">byte</span>[] ipHeader = createIP4Header(udpHeader.length);</span><br><span class="line">        <span class="keyword">byte</span>[] dnsPacket = <span class="keyword">new</span> <span class="keyword">byte</span>[ipHeader.length + udpHeader.length];</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer = ByteBuffer.wrap(dnsPacket);</span><br><span class="line">        buffer.put(ipHeader);</span><br><span class="line">        buffer.put(udpHeader);</span><br><span class="line">        <span class="comment">//将消息发给路由器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProtocolManager.getInstance().sendData(dnsPacket, resolve_server_ip);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组装 UDP 包头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] createUDPHeader(<span class="keyword">byte</span>[] data) &#123;</span><br><span class="line">        IProtocol udpProtocol = ProtocolManager.getInstance().getProtocol(<span class="string">&quot;udp&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (udpProtocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;String, Object&gt; headerInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span> udpPort = (<span class="keyword">char</span>) <span class="keyword">this</span>.port;</span><br><span class="line">        headerInfo.put(<span class="string">&quot;source_port&quot;</span>, udpPort);</span><br><span class="line">        headerInfo.put(<span class="string">&quot;dest_port&quot;</span>, DNS_SERVER_PORT);</span><br><span class="line">        headerInfo.put(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span> udpProtocol.createHeader(headerInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组装 IP 包头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] createIP4Header(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        IProtocol ipPrtocol = ProtocolManager.getInstance().getProtocol(<span class="string">&quot;ip&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ipPrtocol == <span class="keyword">null</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;String, Object&gt; headerInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        headerInfo.put(<span class="string">&quot;data_length&quot;</span>, length);</span><br><span class="line">        ByteBuffer destIP = ByteBuffer.wrap(resolve_server_ip);</span><br><span class="line">        headerInfo.put(<span class="string">&quot;destination_ip&quot;</span>, destIP.getInt());</span><br><span class="line">        <span class="keyword">byte</span> protocol = UDPProtocolLayer.PROTOCOL_UDP;</span><br><span class="line">        headerInfo.put(<span class="string">&quot;protocol&quot;</span>, protocol);</span><br><span class="line">        headerInfo.put(<span class="string">&quot;identification&quot;</span>, transition_id);</span><br><span class="line">        <span class="keyword">return</span> ipPrtocol.createHeader(headerInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析服务器回发的数据包，首先读取头2字节判断 transition_id 是否与我们发送时使用的一致</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headerInfo data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleData</span><span class="params">(HashMap&lt;String, Object&gt; headerInfo)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n==================== DNS START ====================&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] data = (<span class="keyword">byte</span>[]) headerInfo.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Empty data...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(data);</span><br><span class="line">        <span class="keyword">short</span> transitionID = buffer.getShort();</span><br><span class="line">        <span class="keyword">if</span> (transitionID != transition_id) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TransitionID is different!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取2字节flag各个比特位的含义</span></span><br><span class="line">        <span class="keyword">short</span> flag = buffer.getShort();</span><br><span class="line">        readFlags(flag);</span><br><span class="line">        <span class="comment">//下面两个字节表示请求数量(Questions)</span></span><br><span class="line">        <span class="keyword">short</span> questionCount = buffer.getShort();</span><br><span class="line">        System.out.println(<span class="string">&quot;Client send &quot;</span> + questionCount + <span class="string">&quot; requests.&quot;</span>);</span><br><span class="line">        <span class="comment">//两字节表示服务器回复信息的数量</span></span><br><span class="line">        <span class="keyword">short</span> answerCount = buffer.getShort();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server return &quot;</span> + answerCount + <span class="string">&quot; answers.&quot;</span>);</span><br><span class="line">        <span class="comment">//两字节表示数据拥有属性信息的数量</span></span><br><span class="line">        <span class="keyword">short</span> authorityCount = buffer.getShort();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server return &quot;</span> + authorityCount + <span class="string">&quot; authority resources.&quot;</span>);</span><br><span class="line">        <span class="comment">//两字节表示附加信息的数量</span></span><br><span class="line">        <span class="keyword">short</span> additionalInfoCount = buffer.getShort();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server return &quot;</span> + additionalInfoCount + <span class="string">&quot; additional info.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理回复包中的Question部分，这部分湖人查询包中的内容一模一样</span></span><br><span class="line">        readQuestions(questionCount, buffer);</span><br><span class="line">        <span class="comment">//处理服务器返回的信息</span></span><br><span class="line">        readAnswers(answerCount, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析 flag 字段各个比特位的含义</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFlags</span><span class="params">(<span class="keyword">short</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最高字节为1表示该数据包为回复数据包</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; (<span class="number">1</span> &lt;&lt; <span class="number">15</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is packet returned from server...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第9个比特位为1表示客户端请求递归式查询</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Client requests recursive query!(客户端请求递归查询)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第8个比特位为1表示服务器接受递归式查询请求</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server accept recursive query request!(服务器接受递归查询)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第6个比特位表示服务器是否拥有解析信息</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sever own the domain info!(拥有解析信息)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server query domain info from other servers!(无解析信息)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 Question 部分</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> questionCount question 部分的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data          buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readQuestions</span><span class="params">(<span class="keyword">int</span> questionCount, ByteBuffer data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n=============== Queries ===============&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; questionCount; i++) &#123;</span><br><span class="line">            readStringContent(data);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">//查询问题的类型</span></span><br><span class="line">            <span class="keyword">short</span> type = data.getShort();</span><br><span class="line">            <span class="keyword">if</span> (type == QUESTION_TYPE_A) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Request IP for given domain name&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//查询问题的级别</span></span><br><span class="line">            <span class="keyword">short</span> clasz = data.getShort();</span><br><span class="line">            System.out.println(<span class="string">&quot;The class of the request is &quot;</span> + clasz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 Answer 部分</span></span><br><span class="line"><span class="comment">     * 回复信息的格式如下：</span></span><br><span class="line"><span class="comment">     * 第一个字段是 name，它的格式如同请求数据中的域名字符串</span></span><br><span class="line"><span class="comment">     * 第二个字段是类型，2字节</span></span><br><span class="line"><span class="comment">     * 第三字段是级别，2字节</span></span><br><span class="line"><span class="comment">     * 第4个字段是 Time to live, 4字节，表示该信息可以缓存多久</span></span><br><span class="line"><span class="comment">     * 第5个字段是数据内容长度，2字节</span></span><br><span class="line"><span class="comment">     * 第6个字段是内如数组，长度如同第5个字段所示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> answerCount 服务器返回的 answer 部分的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data        buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readAnswers</span><span class="params">(<span class="keyword">int</span> answerCount, ByteBuffer data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n=============== Answers ===============&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 在读取name字段时，要注意它是否使用了压缩方式，如果是那么该字段的第一个字节就一定大于等于192，</span></span><br><span class="line"><span class="comment">         * 也就是它会把第一个字节的最高2比特设置成11，接下来的1字节表示数据在dns数据段中的偏移，</span></span><br><span class="line"><span class="comment">         * 即从DNS报文段开头开始偏移。</span></span><br><span class="line"><span class="comment">         * 因为规定字符串长度不能超过63，即6位，因此若发现字符串的长度超过(或等于)192，就是采用了压缩</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; answerCount; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="number">1</span> + <span class="string">&quot;: Name content in answer filed is:&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (isNameCompression(data.get())) &#123;</span><br><span class="line">                <span class="keyword">int</span> offset = (<span class="keyword">int</span>) data.get();</span><br><span class="line">                <span class="keyword">byte</span>[] array = data.array();</span><br><span class="line">                ByteBuffer dup_buffer = ByteBuffer.wrap(array);</span><br><span class="line">                <span class="comment">//从指定偏移处读取</span></span><br><span class="line">                dup_buffer.position(offset);</span><br><span class="line">                readStringContent(dup_buffer);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                readStringContent(data);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//类型</span></span><br><span class="line">            <span class="keyword">short</span> type = data.getShort();</span><br><span class="line">            System.out.println(<span class="string">&quot;Answer type is : &quot;</span> + type);</span><br><span class="line">            <span class="keyword">if</span> (type == DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This answer contains server string name...&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;(该答复中包含了服务器的字符串名称)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//级别</span></span><br><span class="line">            <span class="keyword">short</span> clasz = data.getShort();</span><br><span class="line">            System.out.println(<span class="string">&quot;Answer class: &quot;</span> + clasz);</span><br><span class="line">            <span class="comment">//接下来4个字节是TTL存活时间</span></span><br><span class="line">            <span class="keyword">int</span> ttl = data.getInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;This content can cache (该域名生存时间为):&quot;</span> + ttl + <span class="string">&quot; seconds(秒)...&quot;</span>);</span><br><span class="line">            <span class="comment">//接下来2字节表示数据长度，长度为4表示IP，其他长度为服务器字符串名称</span></span><br><span class="line">            <span class="keyword">short</span> length = data.getShort();</span><br><span class="line">            <span class="keyword">if</span> (type == DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS) &#123;</span><br><span class="line">                readStringContent(data);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == DNS_ANSWER_HOST_ADDRESS) &#123;</span><br><span class="line">                <span class="comment">//打印服务器的IP</span></span><br><span class="line">                <span class="keyword">byte</span>[] ip = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    ip[j] = data.get();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    InetAddress inetAddress = InetAddress.getByAddress(ip);</span><br><span class="line">                    System.out.println(<span class="string">&quot;IP for domain name is(域名解析得到的IP为): &quot;</span> +</span><br><span class="line">                            inetAddress.getHostAddress());</span><br><span class="line">                    System.out.println(<span class="string">&quot;==================== DNS END ====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析域名字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readStringContent</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> charCount = buffer.get();</span><br><span class="line">        <span class="comment">//如果字符第一个数正确或者使用压缩方式，输出字符串内容</span></span><br><span class="line">        <span class="keyword">while</span> (charCount != <span class="number">0</span> || isNameCompression(charCount)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNameCompression(charCount)) &#123;</span><br><span class="line">                <span class="keyword">int</span> offset = buffer.get();</span><br><span class="line">                <span class="keyword">byte</span>[] array = buffer.array();</span><br><span class="line">                ByteBuffer dup_buffer = ByteBuffer.wrap(array);</span><br><span class="line">                dup_buffer.position(offset);</span><br><span class="line">                readStringContent(dup_buffer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charCount; ++i) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            charCount = buffer.get();</span><br><span class="line">            <span class="keyword">if</span> (charCount != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串是否使用压缩</span></span><br><span class="line"><span class="comment">     * 若 7.8位 为 1，则采用压缩，因为允许的字符串长度最长为 64，即 6位</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 字符串本串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNameCompression</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) != <span class="number">0</span> &amp;&amp; (b &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>稍后进行代码讲解…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DNS-域名解析协议-基本原理介绍&quot;&gt;&lt;a href=&quot;#DNS-域名解析协议-基本原理介绍&quot; class=&quot;headerlink&quot; title=&quot;DNS(域名解析协议)基本原理介绍&quot;&gt;&lt;/a&gt;DNS(域名解析协议)基本原理介绍&lt;/h2&gt;&lt;p&gt;我们这章开始研究和实现一个体系较为复杂的协议，也就是域名解析协议，简写为DNS。该协议几乎也是我们”日用而不知”的幕后英雄，没有它肯定就没有现在的互联网繁荣。&lt;/p&gt;
&lt;p&gt;当我们在浏览器上输入网址，例如&lt;code&gt;www.baidu.com&lt;/code&gt;时，浏览器先通过DNS协议找到与该网址对应的IP地址，然后再使用IP去向服务器获取网页信息。也就是说互联网上的设备其实有两种辨认方法，一种是IP，一种是域名。就如同人的身份证，人有名字，同时也有几十位数字组成的身份证号。&lt;/p&gt;
&lt;p&gt;人与人相互识别时，使用的都是名字，几乎没有人使用身份证号来识别他人的，即使身份证号相对于名字而言更加唯一和准确。说到底是因为人对数字识别很费劲，而记住名字很容易。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://CherryYang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP协议" scheme="http://CherryYang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="计算机网络" scheme="http://CherryYang05.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP协议" scheme="http://CherryYang05.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="DNS协议" scheme="http://CherryYang05.github.io/tags/DNS%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器配置</title>
    <link href="http://cherryyang05.github.io/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://cherryyang05.github.io/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-05-26T14:10:55.000Z</published>
    <updated>2020-05-26T15:05:44.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验内容介绍"><a href="#实验内容介绍" class="headerlink" title="实验内容介绍"></a>实验内容介绍</h3><p>Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 <code>WAMP(Windows+Apache+MySQL+PHP)</code> 和 <code>LAMP(Linux+Apache+MySQL+PHP)</code>架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本实验中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。<br>Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。<br>本实验演示以 kali 64 位操作系统为例。因 kali 系统已经自带 Apache、MySQL 和 PHP，为了解安装流程，请先卸载系统自带软件。</p><a id="more"></a><h3 id="卸载系统原有Apache、MySQL、PHP"><a href="#卸载系统原有Apache、MySQL、PHP" class="headerlink" title="卸载系统原有Apache、MySQL、PHP"></a>卸载系统原有Apache、MySQL、PHP</h3><p>sudo apt-get remove apache2<br>sudo apt-get remove mysql-*<br>sudo apt-get remove php</p><h3 id="在线安装Apache-服务器"><a href="#在线安装Apache-服务器" class="headerlink" title="在线安装Apache 服务器"></a>在线安装Apache 服务器</h3><p>输入命令：<code>sudo apt-get install apache2</code></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/在线安装Apache服务器.png" alt="在线安装Apache服务器"></p><p>输入命令：<code>sudo /etc/init.d/apache2 start</code> 手动启动服务</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/启动Apache服务.png" alt="启动Apache服务"></p><p>以上页面详细介绍了 Debian 发行版 Linux 中 Apache 基本信息，其中：</p><p><strong>Apache 根目录：</strong><br><code>/var/www/html</code></p><p><strong>Apache 配置目录和文件：</strong><br><code>/etc/apache2</code>: Apache 主配置目录， Apache 所有配置文件均在此目录下；<br><code>/etc/apache2/apache2.conf</code>: 主配置文件，可配置 Apache 全局配置；<br><code>/etc/apache2/ports.conf</code>: 端口配置文件。默认情况下，当启用提供 SSL功能的模块时，Apache 监听端口 80，并在端口 443 上进行监听。<br>其它文件略。</p><p><strong>Apache 日志文件：</strong><br><code>/var/log/apache2/access.log</code>: 服务请求日志<br><code>/var/log/apache2/error.log</code>: 服务错误日志</p><p><strong>Apache 基本操作：</strong><br>服务启动：<code>/etc/init.d/apache2 start</code><br>服务停止：<code>/etc/init.d/apache2 stop</code><br>服务重启：<code>/etc/init.d/apache2 restart</code><br>部分 Linux 安装 Apache 后可能出现服务正常运行，相应端口正常打开，但其它主机无法访问情况，此现象一般是因为系统防火墙未开放相应服务端口。在浏览器找那个输入虚拟机的IP，看到：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/Apache服务启动成功.png" alt="Apache服务启动成功"></p><p>说明服务器配置成功！</p><h3 id="安装-MySQL-MariaDB"><a href="#安装-MySQL-MariaDB" class="headerlink" title="安装 MySQL/MariaDB"></a>安装 MySQL/MariaDB</h3><p>本示例采用 MariaDB 代替 MySQL。MariaDB 是 MySQL 的一个分支，现由开源社区维护，采用 GPL 授权许可，其大部分语法与 MySQL 都相同。因 MySQL 被 Oracle收购后有闭源的风险，大部分 Linux 组织均从其套件清单删除了 MySQL，并以MariaDB 代替 MySQL，若一定要使用 MySQL，可通过下载安装包的方式手动安装MySQL。</p><p>安装 MariaDB 服务：<br><code>sudo apt-get install mariadb-server</code><br><code>sudo apt-get install mariadb-client</code></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/安装mariadb.png" alt="安装mariadb"></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/安装mariadb2.png" alt="安装mariadb2"></p><h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><h5 id="首先就是提示没有mariadb-server软件包，类似于这样"><a href="#首先就是提示没有mariadb-server软件包，类似于这样" class="headerlink" title="首先就是提示没有mariadb-server软件包，类似于这样"></a>首先就是提示没有<code>mariadb-server</code>软件包，类似于这样</h5><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/提示没有mariadb软件包.png" alt="提示没有mariadb软件包"></p><p>这个可能是apt版本不够，需要执行<code>sudo apt-get update</code> 进行更新，但是更新实在太慢，我更新了33分钟才更新好，这时候已经快下课了。</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/apt-get-update.png" alt="apt-get-update"></p><h5 id="然后就是出现域名无法解析的错误"><a href="#然后就是出现域名无法解析的错误" class="headerlink" title="然后就是出现域名无法解析的错误"></a>然后就是出现域名无法解析的错误</h5><p>这个错误困扰了我好久，按照网上的方法试了很多，但是还是不行。最后发现是<code>/etc/network/interfaces</code>文件中网关写错了，写成了<code>192.168.1.0</code>，正确的应该是<code>192.168.1.1</code><br>然后修改<code>/etc/resolv.conf</code>文件，增加字段：<code>nameserver 8.8.8.8（好像是谷歌的DNS服务器）</code>，然后执行<code>ifdown -a</code>关闭网卡，<code>ifup -a</code>启动网卡，然后就可以了。</p><p>至于为什么会出现DNS解析错误，一开始我的虚拟机的网络是用的NAT（虚拟地址转换），在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。在NAT模式下，宿主计算机相当于一台开启了DHCP功能的路由器，而虚拟机则是内网中的一台真实主机，通过路由器(宿主计算机)DHCP动态获得网络参数。因此在NAT模式下，虚拟机可以访问外部网络，反之则不行，因为虚拟机属于内网。</p><p>而改成了桥接模式后，虚拟机和宿主计算机处于同等地位（同处一个局域网），虚拟机就像是一台真实主机一样存在于局域网中。因此在桥接模式下，我们就要像对待其他真实计算机一样为其配置IP、网关、子网掩码等等。<br>但是修改<code>/etc/resolv.conf</code>，重启过后就没有了，我们需要安装<code>resolvconfig</code>应用组件：<code>sudo apt-get install resolvconf</code>，在<code>/etc/resolvconf/resolv.conf.d/base</code>文件中添加DNS信息<code>（nameserver 8.8.8.8）</code>，就可以了。</p><p>然后再次重新启动，刚刚的问题解决！</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/resolvconfig应用.png" alt="resolvconfig应用"></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/apt-get更新成功.png" alt="apt-get更新成功"></p><p><strong>配置 Mariadb 的安全选项:</strong><br><code>sudo mysql_secure_installation</code></p><p>此时系统会提示输入数据库 root 用户密码，因系统并未设置相应密码，此时直接按提示回车即可。若提示错误，则 sudo /etc/init.d/mysql restart 命令重启 mysql 服务并重新执行安全选项命令。随后数据库会提示以下安全设置信息，一般设置数据库 root 用户密码即可，其它选项按回车选择默认：</p><ol><li>Enter current password for root (enter for none): 输入当前 root的密码(因新数据库无密码，回车即可)；</li><li>Set root password? [Y/n] 回车，默认为输入 Y；</li><li>New password: 输入新密码；</li><li>Re-enter new password 确认密码；</li><li>Remove anonymous users? [Y/n] 移除匿名用户；</li><li>Disallow root login remotely? [Y/n] 禁止 root 远程登录；</li><li>Remove test database and access to it? [Y/n] 移除测试数据库；</li><li>Reload privilege tables now? [Y/n] 重新加载权限表。</li></ol><p><strong>测试数据库:</strong><br>如图所示，若进入数据库则表示数据库安装成功，sudo mysql -u root -p</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/MySQL.png" alt="MySQL"></p><h3 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h3><p>安装 PHP 除了 PHP 应用程序外，还需安装 PHP 与 Apache、MySQL/MariaDB相关扩展包，扩展包需与软件对应，本例中安装 php7.2 版本，对应扩展包可通过以下命令模糊查询：<br><code>sudo apt-cache search php7</code><br>从查询结果可知，php7.3对应Apache、MySQL扩展包分别为 ：<code>libapahe2-mod-php7.2，php7.2-mysql</code>.如下图所示为安装 PHP 相关软件包。<br><code>sudo apt-get install php7.2 libapahe2-mod-php7.2 php7.2-mysqlPHP</code> 安装完毕后需重启 Apache</p><h3 id="测试PHP页面"><a href="#测试PHP页面" class="headerlink" title="测试PHP页面"></a>测试PHP页面</h3><p>编辑测试文件，如下图所示，在 <code>/var/www/html</code> 目录下新建 <code>test.php</code> 文件，并输入如下所示的测试代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中访问如下：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/安装PHP.png" alt="安装PHP"></p><p><strong>注意：我修改了Apache的端口为8080，因此访问时要在URL后面加上8080端口。</strong></p><h3 id="创建文件上传页面"><a href="#创建文件上传页面" class="headerlink" title="创建文件上传页面"></a>创建文件上传页面</h3><p>文件上传功能由上传文件的 HTML 表单和文件上传脚本构成。在根目录下创建<code>upload.html</code>文件，编辑表单</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/upload.html.png" alt="upload.html"></p><p>在根目录下创建 <code>upload.php</code> 脚本文件，编写文件上传功能代码：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/upload.php.png" alt="upload.php"></p><p>在根目录下创建“upload”目录，用于保存上传的图片<br>然后访问<code>192.168.1.120:8080/upload.html</code></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/访问html.png" alt="访问html"></p><p>选择一个不超过200K的图片文件：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/链接php.png" alt="链接php"></p><p>先修改upload文件夹的权限，上传之后查看服务器中upload文件夹：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/upload文件夹.png" alt="upload文件夹"></p><p>或者查看Apache的属主：<code>ps -ef | grep apache</code>，发现是<code>www-data</code></p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/Apache属主.png" alt="Apache属主"></p><p>然后更改修改目录的所有者：</p><p><img src="/2020/05/26/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/chown更改属主.png" alt="chown更改属主"></p><p>结果和上述一样，大功告成！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实验内容介绍&quot;&gt;&lt;a href=&quot;#实验内容介绍&quot; class=&quot;headerlink&quot; title=&quot;实验内容介绍&quot;&gt;&lt;/a&gt;实验内容介绍&lt;/h3&gt;&lt;p&gt;Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 &lt;code&gt;WAMP(Windows+Apache+MySQL+PHP)&lt;/code&gt; 和 &lt;code&gt;LAMP(Linux+Apache+MySQL+PHP)&lt;/code&gt;架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本实验中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。&lt;br&gt;Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。&lt;br&gt;本实验演示以 kali 64 位操作系统为例。因 kali 系统已经自带 Apache、MySQL 和 PHP，为了解安装流程，请先卸载系统自带软件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux实验" scheme="http://CherryYang05.github.io/categories/Linux%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="Linux服务器" scheme="http://CherryYang05.github.io/tags/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机知识总结（二）</title>
    <link href="http://cherryyang05.github.io/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://cherryyang05.github.io/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-05-24T09:28:44.000Z</published>
    <updated>2020-05-24T09:45:08.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三、GC算法和收集器"><a href="#三、GC算法和收集器" class="headerlink" title="三、GC算法和收集器"></a>三、GC算法和收集器</h2><p>本文参考：<br>Oracle Java JVM Standard Options：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a><br>HotSpot Glossary of Terms：<a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a><br>周志明《深入理解Java虚拟机》第二版</p><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0的对象就是不可能再被使用的。<br>这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决对象之前相互循环引用的问题。所谓对象之间的相互引用问题，通过下面代码所示：除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三、GC算法和收集器&quot;&gt;&lt;a href=&quot;#三、GC算法和收集器&quot; class=&quot;headerlink&quot; title=&quot;三、GC算法和收集器&quot;&gt;&lt;/a&gt;三、GC算法和收集器&lt;/h2&gt;&lt;p&gt;本文参考：&lt;br&gt;Oracle Java JVM Standard Opti
      
    
    </summary>
    
    
      <category term="Java虚拟机" scheme="http://CherryYang05.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://CherryYang05.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机知识总结(一)</title>
    <link href="http://cherryyang05.github.io/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://cherryyang05.github.io/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-05-24T06:42:02.000Z</published>
    <updated>2020-05-24T09:51:17.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java虚拟机介绍"><a href="#Java虚拟机介绍" class="headerlink" title="Java虚拟机介绍"></a>Java虚拟机介绍</h2><p>Java虚拟机(Java Virtual Machine，JVM)，一种能够运行Java字节码的虚拟机。作为一种编程语言的虚拟机，实际上<br>不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。<br><a id="more"></a></p><h2 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h2><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/JVM基本结构.png" alt="JVM基本结构"></p><p>JVM由三个主要的子系统构成</p><ul><li>类加载子系统</li><li>运行时数据区（内存结构）</li><li>执行引擎</li></ul><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/类加载机制.png" alt="类的生命周期"></p><ol><li>加载<br>将<code>.class</code>文件从磁盘读到内存</li><li>链接<ol><li>验证<br>验证字节码文件的正确性</li><li>准备<br>给类的静态变量分配内存</li><li>解析<br>类加载器装入类所引用的其他所有类(静态链接)<br>静态链接：解析阶段，由符号引用转化为直接引用<br>动态链接：程序运行期间，由符号引用转化为直接引用</li></ol></li><li>初始化<br>为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序<br>编写者为变量分配的真正的初始值，执行静态代码块</li><li>使用</li><li>卸载</li></ol><h3 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h3><ul><li>启动类加载器(Bootstrap ClassLoader)<br>负责加载JRE的核心类库，如JRE目标下的<code>rt.jar</code>,<code>charsets.jar</code>等</li><li>扩展类加载器(Extension ClassLoader)<br>负责加载JRE扩展目录<code>ext</code>中jar类包</li><li>系统类加载器(Application ClassLoader)<br>负责加载<code>ClassPath</code>路径下的类包</li><li>用户自定义加载器(User ClassLoader)<br>负责加载用户自定义路径下的类包</li></ul><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/加载器.png" alt="加载器"></p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><h4 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h4><p>当一个<code>ClassLoader</code>加载一个类的时候，除非显式的使用另一个<code>ClassLoader</code>,该类所依赖和引用的类也由这个<code>ClassLoader</code>载入</p><h4 id="双亲委派机制-1"><a href="#双亲委派机制-1" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>指先委托父类加载器寻找目标类，在找不到的情况下载自己的路径中查找并载入目标类。实际上<code>双亲委派机制</code>实则<code>父类委派机制</code>。</p><h5 id="双亲委派模式的优势"><a href="#双亲委派模式的优势" class="headerlink" title="双亲委派模式的优势"></a>双亲委派模式的优势</h5><ul><li>沙箱安全机制：比如自己写的<code>String.class</code>类不会被加载，这样可以防止核心库被随意篡改</li><li>避免类的重复加载：当父<code>ClassLoader</code>已经加载了该类的时候，就不需要子<code>ClassLoader</code>再加载一次</li></ul><p><em>要确定一个类的唯一性，要获得该类的类加载器实例以及类的全限定名。</em></p><p>不同的类加载器加载同一个<code>class</code>文件是不同的类模板信息</p><p>为什么要打破双亲委派机制？<br>Tomcat为了做wap包隔离</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/运行时数据区.png" alt="运行时数据区"></p><p>堆：用来放类的实例对象<br>栈：栈帧，用来存放方法，线程</p><h4 id="方法区（Method-Area）-永久代-持久代jdk1-8以前，元空间"><a href="#方法区（Method-Area）-永久代-持久代jdk1-8以前，元空间" class="headerlink" title="方法区（Method Area）(永久代/持久代jdk1.8以前，元空间)"></a>方法区（Method Area）(永久代/持久代jdk1.8以前，元空间)</h4><p>类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)</p><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><ul><li>YoungGC/MinorGC</li><li>CMS OldGC</li><li>MajorGC/FullGC</li></ul><p>虚拟机启动时自动分配创建，用于存放对象的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内存是将抛出<code>OutOfMemoryError(OOM)</code>异常。同时也是垃圾收集器管理的主要区域。</p><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/堆.png" alt="堆"></p><p>当年龄到15时，转入老年代</p><h5 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h5><p>类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。<br>新生代分为两部分：伊甸区<code>（Eden space）</code>和幸存者区<code>（Survivor space）</code>，所有的类都是在伊甸区被new出来的。<br>幸存区又分为<code>From</code>和<code>To</code>区。当<code>Eden</code>区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将<code>Eden</code>区进行垃圾回<br>收<code>（Minor GC）</code>，将<code>Eden</code>区中的不再被其它对象应用的对象进行销毁。然后将<code>Eden</code>区中剩余的对象移到<code>From Survivor</code>区。若<code>From Survivor</code>区也满了，再对该区进行垃圾回收，然后移动到<code>To Survivor</code>区。</p><h5 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h5><p>新生代经过多次GC仍然存货的对象移动到老年区。若老年代也满了，这时候将发生<code>Major GC</code>（也可以叫<code>Full GC</code>），进行老年区的内存清理。若老年区执行了<code>Full GC</code>之后发现依然无法进行对象的保存，就会抛出<code>OOM（OutOfMemoryError）</code>异常</p><h5 id="元空间（Meta-Space）"><a href="#元空间（Meta-Space）" class="headerlink" title="元空间（Meta Space）"></a>元空间（Meta Space）</h5><p>在<code>JDK1.8</code>之后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。</p><p><strong>为什么移除了永久代？</strong><br>参考官方解释 <strong><a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></strong></p><p>大概意思是移除永久代是为融合<code>HotSpot</code>与<code>JRockit</code>而做出的努力，因为<code>JRockit</code>没有永久代，不需要配置永久代。</p><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/堆和GC.png" alt="新生代和老年代转化"></p><h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h4><p>Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致.</p><h4 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h4><p>和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记<code>native</code>方法，在<code>Execution Engine</code>执行时加载本地方法库</p><h4 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h4><p>就是一个指针，指向方法区中的方法字节码（用来存储指向下一跳指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计</p><hr><h6 id="将下面代码编译生成Class字节码并反汇编："><a href="#将下面代码编译生成Class字节码并反汇编：" class="headerlink" title="将下面代码编译生成Class字节码并反汇编："></a>将下面代码编译生成<code>Class</code>字节码并反汇编：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      JVM jvm = <span class="keyword">new</span> JVM();</span><br><span class="line">      System.out.println(jvm.math());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编后：<code>(javap -c JVM.class &gt; JVM.txt)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;JVM.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JVM</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_5</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      11: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">14</span>: iload_1</span><br><span class="line">      15: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">18</span>: iload_3</span><br><span class="line">      <span class="number">19</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #4                  // class JVM</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #5                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      12: invokevirtual #6                  // Method math:()I</span><br><span class="line">      15: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多其实都是编译原理的知识，下面是数据区：</p><p><img src="/2020/05/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/数据区.png" alt="数据区"></p><p>反汇编之后前面的数字序号便是程序计数器<code>PC</code></p><p>目前市面上大部分虚拟机都是用<code>C/C++</code>实现的，实际上最后启动线程都是通过<code>C/C++</code>库来调用操作系统内核函数实现。</p><p>利用<code>javap -v JVM.class &lt; dynamicLink.txt</code>查看动态链接详细信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">Classfile /G:/JVM.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">5</span>-<span class="number">24</span>; size <span class="number">493</span> bytes</span><br><span class="line">  MD5 checksum 5cdaa7b4d5fb74c45c86c10186ae5c8c</span><br><span class="line">  Compiled from <span class="string">&quot;JVM.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#18         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #19.#20        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #21.#22        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #23            // JVM</span><br><span class="line">   #5 = Methodref          #4.#18         // JVM.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #6 = Methodref          #4.#24         // JVM.math:()I</span><br><span class="line">   #7 = Class              #25            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               math</span><br><span class="line">  #13 = Utf8               ()I</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               SourceFile</span><br><span class="line">  #17 = Utf8               JVM.java</span><br><span class="line">  #18 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #19 = Class              #26            // java/lang/System</span><br><span class="line">  #20 = NameAndType        #27:#28        // out:Ljava/io/PrintStream;</span><br><span class="line">  #21 = Class              #29            // java/io/PrintStream</span><br><span class="line">  #22 = NameAndType        #30:#31        // println:(I)V</span><br><span class="line">  #23 = Utf8               JVM</span><br><span class="line">  #24 = NameAndType        #12:#13        // math:()I</span><br><span class="line">  #25 = Utf8               java/lang/Object</span><br><span class="line">  #26 = Utf8               java/lang/System</span><br><span class="line">  #27 = Utf8               out</span><br><span class="line">  #28 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #29 = Utf8               java/io/PrintStream</span><br><span class="line">  #30 = Utf8               println</span><br><span class="line">  #31 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JVM</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iconst_5</span><br><span class="line">         <span class="number">3</span>: istore_2</span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">9</span>: imul</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        11: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">14</span>: iload_1</span><br><span class="line">        15: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #4                  // class JVM</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #5                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">11</span>: aload_1</span><br><span class="line">        12: invokevirtual #6                  // Method math:()I</span><br><span class="line">        15: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;JVM.java&quot;</span></span><br></pre></td></tr></table></figure><p>第一段的<code>Constant pool</code>是符号引用</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java虚拟机介绍&quot;&gt;&lt;a href=&quot;#Java虚拟机介绍&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机介绍&quot;&gt;&lt;/a&gt;Java虚拟机介绍&lt;/h2&gt;&lt;p&gt;Java虚拟机(Java Virtual Machine，JVM)，一种能够运行Java字节码的虚拟机。作为一种编程语言的虚拟机，实际上&lt;br&gt;不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java虚拟机" scheme="http://CherryYang05.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://CherryYang05.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>DHCP主机动态配置协议详解以及代码实现</title>
    <link href="http://cherryyang05.github.io/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://cherryyang05.github.io/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-05-15T10:20:18.000Z</published>
    <updated>2020-05-20T15:39:32.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、DHCP介绍"><a href="#一、DHCP介绍" class="headerlink" title="一、DHCP介绍"></a>一、DHCP介绍</h2><h3 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1. 简要介绍"></a>1. 简要介绍</h3><p>DHCP协议在我们日常生活中应该是最常见而又经常被忽略的一种协议了。当你走进一间屋子，手机自动连上了WiFi，当你离开了屋子，又自动断开了WiFi……这一系列的幕后都是DHCP协议在默默工作。</p><p>DHCP协议(Dynamic Host Configuration Protocol)是一个基于UDP协议的局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p><p>该协议的做大作用是动态的为加入网络的设备分配IP地址，在该协议出现前，IP地址的分配基于静态模式，你把设备的mac地址手动在路由器设置，然后路由器自动生成一个IP与你的mac地址绑定起来。这种应用在有线网络时代可以适用，但在无线时代，每时每刻可能有不同的设备加入或离开网络，因此原有静态匹配IP的做法不再适合。</p><p>DHCP协议的诞生就是为了迎合在无线情况下，网络内部连接设备不断变化的情况。它包含两部分，一是分配IP地址，二是支持客户端请求，服务器应答，使得两者之间有效交换配置信息。</p><p>DHCP最重要功能显然是动态分配IP地址，当我们的设备连接上网络之后里面获得一个可用的IP地址，就得感谢该协议的执行，现在我们大多数设备都依靠DHCP来从路由器动态获得IP<br><a id="more"></a></p><h3 id="2-DHCP的IP租借"><a href="#2-DHCP的IP租借" class="headerlink" title="2. DHCP的IP租借"></a>2. DHCP的IP租借</h3><p>DHCP协议能够维护一个动态的IP池，根据设备加入和离开网络回收或分发可用IP，它甚至能实现多个设备共享相同IP。DHCP协议的实现基于UDP，需要IP的设备和具备分配IP能力的设备根据DHCP协议的方式封装数据包，然后通过UDP协议发送给对方。有了该协议后，我们上网时不再麻烦的去配置各种信息，设备和路由器之间相互通信后，自动配置好相应信息，我们只要等着配置完毕然后上网就行。</p><p>DHCP支持三种地址分配方式，一种是手动分配，由管理员手动将指定IP地址分发给特定设备；第二种是自动分配，它从当前可用的IP地址池中选出一个，永久的分发给某一台特定设备；第三种是动态分配，它从IP地址池中选出一个分发给某台设备一段时间，时间到了后收回，或者设备离开网络后通知路由器主动收回，由此可见，第二种和第三种区别不大</p><p>使用动态分配方式时，管理员指定一系列可以分配的IP，然后DHCP服务器会自动维护哪些IP已经分配，哪些IP可以使用。同时服务器指定分配的IP使用时长，一旦超时后，客户必须主动向服务器请求续租，例如上图就有对应按钮，或者请求重新从服务器获得一个新的IP地址，这个请求应答过程将是我们研究和实现的重点。</p><p>DHCP协议动态分配IP的好处显而易见，首先是自动化，省却了管理员耗时耗力的维护，其次是集中管理，从服务器就可以得知IP的使用情况，由此有效防止IP冲突。而且还能实现地址的共享和重用，如果一台设备不活跃，例如关机或离开网络，协议可以及时收回IP，分发给在网络中的其他设备。</p><p>在DHCP协议管理下，所有设备只能”租借“IP而不能“拥有”IP。有租借就必须有管理，DHCP协议的主要内容就在这里。租借时常根据设备的使用情况而定，作为服务器的设备租借时间必须很长，而对于手持设备而言，租借时间可以很短。在很多情况下，管理员为了防止IP被长时间无效占用，例如某台设备计划租借一个月，但它运行一天就关机了，那么这个IP就会在余下29天浪费掉，因此管理员会强制设备租借短时期，时期到了后再跟服务器请求延长租借期。</p><p>管理员一般把IP池划分为若干类别，不同类别对应不同租期，然后根据接入设备的类型赋予不同类别的IP。一旦租期抵达一半时，设备就开始于服务器协商以便延长租期。</p><p>下面是IP租借的流程图：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP租借.png" alt="IP租借"></p><p>上图描述了设备向DHCP服务器租借IP8天流程，其中在第4天要与服务器协商续租。租借IP的设备需要保持两个时钟，时钟T1在租借期过了一半时触发，此时设备向服务器请求续租；如果续租不成功，第二个时钟在租期87.5%时触发，设备向另一个DHCP服务器发起租借IP的请求。我们后面用代码实现协议时，主要通过构造数据包完成上面所述流程。</p><p>DHCP协议时典型的服务器客户端应用模式。需要IP的设备是客户端，分发IP的设备是服务器，两者通过互发消息完成一项任务。他们之间的交互可以由下图表达：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP握手.jpg" alt="DHCP握手"></p><p>类似于<code>TCP</code>的握手，但是又比TCP简单不少。</p><h2 id="二、DHCP主机动态配置协议解析和数据包格式说明"><a href="#二、DHCP主机动态配置协议解析和数据包格式说明" class="headerlink" title="二、DHCP主机动态配置协议解析和数据包格式说明"></a>二、DHCP主机动态配置协议解析和数据包格式说明</h2><h3 id="1-查看DHCP数据包"><a href="#1-查看DHCP数据包" class="headerlink" title="1. 查看DHCP数据包"></a>1. 查看DHCP数据包</h3><p>打开网络封包分析软件WireShack，输入过滤条件<code>bootp.option.type == 53</code>(或者<code>dhcp.option.type == 53</code>也可)，在命令行中输入<code>ipconfig/renew</code>，表示续租DHCP服务器，我们获取这样的数据包：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP数据包介绍.png" alt="DHCP数据包介绍"></p><p>点开一个数据包，看到：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/具体格式.png" alt="具体格式"></p><p>我们看到DHCP协议数据包的组成格式为<code>IP数据包-&gt;UDP数据包-&gt;Boostrap Protocoal数据包(也就是DHCP数据包)</code><br><strong>【注】Boostrap 是DHCP协议的前身，它叫主机静态配置协议。DHCP其实是它的扩展，将原来静态配置的过程动态化，于是配置起来更加灵活方便，只不过DHCP数据包的依然以Boostrap协议数据包为基础。</strong></p><p>我们点开DHCP看看具体内容：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP具体内容.png" alt="DHCP具体内容"></p><p>通过观察，我们大概可以知道DHCP数据包大概有哪些字段，要了解这些字段的作用，我们还得充分了解协议的具体交互流程。DHCP协议以客户端&lt;-&gt;服务器的方式进行交互，整个过程由客户端主导，服务器被动回应，因此掌握客户端的运行状态，我们就可以掌握DHCP的协议交互流程。</p><h3 id="2-DHCP流程"><a href="#2-DHCP流程" class="headerlink" title="2. DHCP流程"></a>2. DHCP流程</h3><p>DHCP在执行时维护了一个状态机，该状态机由八个状态组成：<br>客户端在运行时维护一个内部状态机，其运行过程如下：</p><ol><li><code>INIT</code>状态。客户端创建一个DHCPDISCOVER消息在局域网内广播，查询可用的DHCP服务器，然后进入<code>SELECTING</code>状态。</li><li><code>SELECTING</code> 状态。局域网内的DHCP收到广播消息后，发送<code>DHCPOFFER</code>消息，客户端会收到一个或多个DHCP服务器的回应，然后它从众多回应中选取一个服务器，向它发送<code>DHCPREQUEST</code>消息，然后进入<code>REQUESTING</code>状态。</li><li><p><code>REQUESTING</code>状态。客户端向服务器发送<code>DHCPREQUEST</code>消息中包含了它对服务器的数据请求，例如可用IP地址以及各类配置参数，请求发送出去后它等待服务器回应。服务器会返回<code>DHCPACK</code>消息，里面包含了客户端想要的可用IP以及配置参数等信息。<br>收到消息后，客户端检测服务器返回的IP地址是否可用，可用的话进入使用状态并像上一节描述的那样设置两个超时时钟。如果客户端发现IP地址不可用，它向服务器发送<code>DHCPDECLINE</code>消息，然后转入状态1。<br>如果客户端从服务器收到的是DHCPNAK消息，它表示服务器拒绝向客户端提供服务，因此客户端重新进入状态1.</p></li><li><p><code>INIT-REBOOT</code>状态。如果客户端已经租借到IP，它重启后进入该状态。此时它会向服务器发送DHCPREQUEST消息，重新确定它对IP的使用权，然后客户端进入REBOOTING状态，等待服务器反应。</p></li><li><p><code>REBOOTING</code>状态。此时客户正在等待服务器返回确认消息，此时会有3中情况。一是客户端收到服务器发来的DHCPACK消息，表明可以继续使用它当前IP,于是客户端进入BOUND状态；二是，客户端得到DHCPACK回应，然后发现它原来使用的IP在自己关机或重启时，被其他设备抢夺了，于是他想服务器发送DHCPDECLINE消息，然后进入状态1；三是收到服务器发来的DHCPNAK消息，这表明服务器告诉客户端IP不能再继续使用，于是客户端进入状态1.</p></li><li><p><code>BOUND</code>状态。此时客户端得到可用IP地址，并进入使用状态。此时它启动两个时钟，T1和T2。当T1超时时，它进入状态RENEWING。如果客户端主动要放弃使用当前IP，它会向服务器发送DHCPRELEASE消息，然后进入状态1.</p></li><li><p><code>RENEWING</code>状态。此时客户端希望续租当前IP，于是他想客户端发送DHCPREQUEST消息，然后等待服务器确认。此时客户端要面临三种情况，一是服务器返回DHCPACK消息，它可以继续使用当前IP；二是收到DHCPNAK消息，服务器拒绝客户端继续租用当前IP；三是客户端的T2时钟超时，客户端进入REBINGDING状态。</p></li><li><p><code>REBIDING</code>状态。此时客户端无法继续续租原有IP，于是它持续向局域网广播DHCPREQUEST消息，直到有服务器响应它为止。此时客户端又面临三种情况。一是有服务器向客户端返回DHCPACK消息，于是客户端可以使用新分配的IP；二是服务器返回DHCPNAK消息，这表明服务器希望客户端重新启动租借流程，于是客户端进入INIT状态；第三是，在收到回应前，客户端当前租用的IP到期，它重新进入INIT状态。</p></li></ol><p>为了简单起见，我们将以客户端的方式编写代码，上面的流程状态可以使用下图统一描述：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/状态机.png" alt="状态机"></p><h3 id="3-字段详解"><a href="#3-字段详解" class="headerlink" title="3. 字段详解"></a>3. 字段详解</h3><p>首先完成第一步，客户端向局域网广播消息，然后收到服务器应答。下面是DHCP消息的具体格式：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/DHCP具体格式.png" alt="DHCP具体格式"></p><p>上面的是前面抓包时对应的DHCP部分，依次解析各个字段：</p><ul><li><code>op</code>字段1字节，它表明消息类型，请求消息使用数值1，回应消息使用数值2</li><li><code>HType</code>1字节，它表明消息发送所使用的网络类型，由于我们默认使用互联网，因此它的值固定为1</li><li><code>HLen</code>字段1字节，它表明设备硬件地址的长度，由于我们默认使用mac地址，因此该字段固定为6</li><li><code>Hops</code>字段1字节，它表明数据包可以跨越几个不同网络，该字段的作用我们在前面traceroute程序中了解过，由于我们希望限制消息在当前局域网内流通，因此设置为0</li><li><code>XID</code>字段4字节。它与ICMP消息中的session作用一样，用来标志一次对话过程</li><li><code>Secs</code>字段2字节。它用来表明客户端发出请求后等待的时间，一般该字段不常使用，我们将它固定为0</li><li><code>Flags</code>字段2字节，取值0或1，如果设置为1，客户端要求服务器以广播的方式发送回应消息，因为此时客户端可能还没有IP地址</li><li><code>CIAddr</code>字段4字节，它存放客户端当前IP地址，如果客户端当前有IP，而且进入状态BOUND,RENEWING状态，其他情况下统一设置为0</li><li><code>YIAddr</code>字段4字节，这是服务器返回给客户端使用的IP</li><li><code>SIAddr</code>字段4字节，服务器IP地址，它有点特殊，这个IP是不一定是当前交互的服务器IP，而是设备下次启动时去获取IP地址的服务器IP</li><li><code>GIAddr</code>字段4字节，网关IP，当DHCP服务器不在本地局域网时，设备将通过该IP将数据包转发给处于另一个局域网的服务器，通常情况下使用不到</li><li><code>CHAddr</code>字段16字节，设备的硬件地址。由于我们默认设备使用mac地址，因此只使用到6个字节，其余10个字节用0填充</li><li><code>SName</code>字段64个字节，该字段用做DHCP服务器的字符串名称</li><li><code>File</code>字段128字节，该字段用于在设备和服务器间交换特定信息</li><li><code>Options</code>字段，可变长。该字段用于设备和服务器间交换多种配置信息</li></ul><p>接下来我们看看<code>Options</code>字段，由于所有信息的交互都存储在该字段，因此我们需搞清楚它的结构。在该字段开始前是4个字节的<code>魔术字</code>，固定为<code>99.130.83.99</code>(十六进制：63 82 53 63),然后才是一系列Option数据结构，Option数据结构组成如下：</p><p><img src="/2020/05/15/DHCP%E4%B8%BB%E6%9C%BA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/option组成.png" alt="option组成"></p><p>每个<code>Option</code>由三字段组成，第一字段是<code>Code</code>,用来表明当前<code>Option</code>类型，它有两个特殊值，一个是<code>0</code>，它表示当前<code>Option</code>只有这一个字节，另一个特殊值是<code>255</code>，它表示后续不再含有<code>Option</code>结构体；第二字段是<code>len</code>，用来标志数据段的长度；第三字段是<code>Data</code>，用来存储数据。</p><p>由于Option结构体用于客户端与服务器进行数据交换，因此它的种类相当繁杂。</p><p>代码实现将在下一篇文章中实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、DHCP介绍&quot;&gt;&lt;a href=&quot;#一、DHCP介绍&quot; class=&quot;headerlink&quot; title=&quot;一、DHCP介绍&quot;&gt;&lt;/a&gt;一、DHCP介绍&lt;/h2&gt;&lt;h3 id=&quot;1-简要介绍&quot;&gt;&lt;a href=&quot;#1-简要介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 简要介绍&quot;&gt;&lt;/a&gt;1. 简要介绍&lt;/h3&gt;&lt;p&gt;DHCP协议在我们日常生活中应该是最常见而又经常被忽略的一种协议了。当你走进一间屋子，手机自动连上了WiFi，当你离开了屋子，又自动断开了WiFi……这一系列的幕后都是DHCP协议在默默工作。&lt;/p&gt;
&lt;p&gt;DHCP协议(Dynamic Host Configuration Protocol)是一个基于UDP协议的局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。&lt;/p&gt;
&lt;p&gt;该协议的做大作用是动态的为加入网络的设备分配IP地址，在该协议出现前，IP地址的分配基于静态模式，你把设备的mac地址手动在路由器设置，然后路由器自动生成一个IP与你的mac地址绑定起来。这种应用在有线网络时代可以适用，但在无线时代，每时每刻可能有不同的设备加入或离开网络，因此原有静态匹配IP的做法不再适合。&lt;/p&gt;
&lt;p&gt;DHCP协议的诞生就是为了迎合在无线情况下，网络内部连接设备不断变化的情况。它包含两部分，一是分配IP地址，二是支持客户端请求，服务器应答，使得两者之间有效交换配置信息。&lt;/p&gt;
&lt;p&gt;DHCP最重要功能显然是动态分配IP地址，当我们的设备连接上网络之后里面获得一个可用的IP地址，就得感谢该协议的执行，现在我们大多数设备都依靠DHCP来从路由器动态获得IP&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://CherryYang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP协议" scheme="http://CherryYang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="计算机网络" scheme="http://CherryYang05.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP协议" scheme="http://CherryYang05.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="DHCP" scheme="http://CherryYang05.github.io/tags/DHCP/"/>
    
  </entry>
  
  <entry>
    <title>��Դ������վ</title>
    <link href="http://cherryyang05.github.io/2020/05/13/%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99/"/>
    <id>http://cherryyang05.github.io/2020/05/13/%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99/</id>
    <published>2020-05-13T06:32:31.000Z</published>
    <updated>2021-03-01T15:36:19.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="һЩ��Դ������վ����"><a href="#һЩ��Դ������վ����" class="headerlink" title="һЩ��Դ������վ����"></a>һЩ��Դ������վ����</h2><h4 id="��Դ��վ����"><a href="#��Դ��վ����" class="headerlink" title="��Դ��վ����"></a>��Դ��վ����</h4><ul><li>�Ѻ���Դ����վ��<a href="http://mirrors.sohu.com/">http://mirrors.sohu.com/</a></li><li>���׿�Դ����վ��<a href="http://mirrors.163.com/">http://mirrors.163.com/</a></li><li>��Դ�й���<a href="http://mirrors.oschina.net/">http://mirrors.oschina.net/</a></li><li>�׶����߿Ƽ��ɷ����޹�˾��<a href="http://mirrors.yun-idc.com/">http://mirrors.yun-idc.com/</a></li><li>�����ƿ�Դ����<a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com/</a></li><li>LUPA��<a href="http://mirror.lupaworld.com/">http://mirror.lupaworld.com/</a></li><li>���ݱ��ؿ�ķ�����������޹�˾(ԭcn99����<a href="http://centos.bitcomm.cn/">http://centos.bitcomm.cn/</a></li></ul><a id="more"></a><h4 id="��ѧУ԰����"><a href="#��ѧУ԰����" class="headerlink" title="��ѧУ԰����"></a>��ѧУ԰����</h4><ul><li>��ɽ��ѧ����<a href="http://mirror.sysu.edu.cn/">http://mirror.sysu.edu.cn/</a></li><li>ɽ��������ѧ��<a href="http://mirrors.sdutlinux.org/">http://mirrors.sdutlinux.org/</a></li><li>��������ҵ��ѧ��<a href="http://run.hit.edu.cn/">http://run.hit.edu.cn/</a></li><li>�й����ʴ�ѧ��<a href="http://cugbteam.org/">http://cugbteam.org/</a></li><li>����������ѧ��<a href="http://mirror.dlut.edu.cn/">http://mirror.dlut.edu.cn/</a></li><li>������ҵ��ѧ?<a href="http://cs3.swfu.edu.cn/cs3guide.html">http://cs3.swfu.edu.cn/cs3guide.html</a></li><li>����������ѧ�������������Է��ʣ������� CentOS ����<a href="http://ubuntu.buct.edu.cn/">http://ubuntu.buct.edu.cn/</a></li><li>����ѧ��<a href="http://mirror.tju.edu.cn/">http://mirror.tju.edu.cn/</a></li><li>���ϴ�ѧ��<a href="http://linux.swu.edu.cn/swudownload/Distributions/">http://linux.swu.edu.cn/swudownload/Distributions/</a></li><li>�ൺ��ѧ��<a href="http://mirror.qdu.edu.cn/">http://mirror.qdu.edu.cn/</a></li><li>�Ͼ�ʦ����ѧ��<a href="http://mirrors.njnu.edu.cn/">http://mirrors.njnu.edu.cn/</a></li><li>����������ϢѧԺ��?<a href="http://mirrors.neusoft.edu.cn/">http://mirrors.neusoft.edu.cn/</a></li><li>�㽭��ѧ��<a href="http://mirrors.zju.edu.cn/">http://mirrors.zju.edu.cn/</a></li><li>���ݴ�ѧ��<a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a></li><li>���Ŵ�ѧ��<a href="http://mirrors.xmu.edu.cn/">http://mirrors.xmu.edu.cn/</a></li><li>����������ѧ��<br><a href="http://mirror.bit.edu.cn?(IPv4">http://mirror.bit.edu.cn?(IPv4</a> only)<br><a href="http://mirror.bit6.edu.cn?(IPv6">http://mirror.bit6.edu.cn?(IPv6</a> only)</li><li>������ͨ��ѧ��<br><a href="http://mirror.bjtu.edu.cn?(IPv4">http://mirror.bjtu.edu.cn?(IPv4</a> only)<br><a href="http://mirror6.bjtu.edu.cn?(IPv6">http://mirror6.bjtu.edu.cn?(IPv6</a> only)<br><a href="http://debian.bjtu.edu.cn?(IPv4+IPv6">http://debian.bjtu.edu.cn?(IPv4+IPv6</a>)</li><li>�Ϻ���ͨ��ѧ��<br><a href="http://ftp.sjtu.edu.cn/?(IPv4">http://ftp.sjtu.edu.cn/?(IPv4</a> only)<br><a href="http://ftp6.sjtu.edu.cn?(IPv6">http://ftp6.sjtu.edu.cn?(IPv6</a> only)</li><li>�廪��ѧ��<br><a href="http://mirrors.tuna.tsinghua.edu.cn/?(IPv4+IPv6">http://mirrors.tuna.tsinghua.edu.cn/?(IPv4+IPv6</a>)<br><a href="http://mirrors.6.tuna.tsinghua.edu.cn/?(IPv6">http://mirrors.6.tuna.tsinghua.edu.cn/?(IPv6</a> only)<br><a href="http://mirrors.4.tuna.tsinghua.edu.cn/?(IPv4">http://mirrors.4.tuna.tsinghua.edu.cn/?(IPv4</a> only)</li><li>�й���ѧ������ѧ��<br><a href="http://mirrors.ustc.edu.cn/?(IPv4+IPv6">http://mirrors.ustc.edu.cn/?(IPv4+IPv6</a>)<br><a href="http://mirrors4.ustc.edu.cn/">http://mirrors4.ustc.edu.cn/</a><br><a href="http://mirrors6.ustc.edu.cn/">http://mirrors6.ustc.edu.cn/</a></li><li>������ѧ��<br><a href="http://mirror.neu.edu.cn/?(IPv4">http://mirror.neu.edu.cn/?(IPv4</a> only)<br><a href="http://mirror.neu6.edu.cn/?(IPv6">http://mirror.neu6.edu.cn/?(IPv6</a> only)</li><li>���пƼ���ѧ��<br><a href="http://mirrors.hust.edu.cn/">http://mirrors.hust.edu.cn/</a><br><a href="http://mirrors.hustunique.com/">http://mirrors.hustunique.com/</a></li><li>���ӿƼ���ѧ��<a href="http://ubuntu.uestc.edu.cn/">http://ubuntu.uestc.edu.cn/</a></li><li>���ӿƴ����۹�����(Raspbian��һϵͳ����)?<a href="http://raspbian.cnssuestc.org/">http://raspbian.cnssuestc.org/</a></li><li>���ӿƴ��ǳ�������(����С�ڷ����澵��)?<a href="http://mirrors.stuhome.net/">http://mirrors.stuhome.net/</a></li></ul><h4 id="PyPi-����"><a href="#PyPi-����" class="headerlink" title="PyPi ����"></a>PyPi ����</h4><ul><li>���꣺<a href="http://pypi.douban.com/">http://pypi.douban.com/</a></li><li>ɽ��������ѧ��<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></li><li>��ɽ��ѧ��<a href="http://mirror.sysu.edu.cn/pypi/">http://mirror.sysu.edu.cn/pypi/</a></li><li>V2EX��<a href="http://pypi.v2ex.com/simple/">http://pypi.v2ex.com/simple/</a></li><li><p>RubyGems ����</p></li><li><p>��ɽ��ѧ��<a href="http://mirror.sysu.edu.cn/rubygems/">http://mirror.sysu.edu.cn/rubygems/</a></p></li><li>ɽ��������ѧ��<a href="http://ruby.sdutlinux.org/">http://ruby.sdutlinux.org/</a></li><li>�Ա�����<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a></li></ul><h4 id="npm-����"><a href="#npm-����" class="headerlink" title="npm ����"></a>npm ����</h4><ul><li>cnpmjs��<a href="http://cnpmjs.org/">http://cnpmjs.org/</a></li></ul><p>��Debian�����汾�����ص�ַ��<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># ����Ϊdebian-9.6������ص�ַ����ͬ�����Ӧ��ͬ��Linux���滷��</span><br><span class="line"> </span><br><span class="line"># �������ص�ַ �����������ļ���һ��ֻ���ص�һ�������ˣ���ȻҲ����ȫ�����ڣ�����ʱ��ѡ���һ�����̣�����㰲װ��ʱ��ѡ��������Ƚ϶࣬���ܻ���ʾ�����ڶ��Ż��ߵ����Ź���</span><br><span class="line">���ӣ�https:&#x2F;&#x2F;cdimage.debian.org&#x2F;debian-cd&#x2F;current&#x2F;i386&#x2F;iso-dvd&#x2F;debian-9.6.0-i386-DVD-1.iso</span><br><span class="line">���ӣ�https:&#x2F;&#x2F;cdimage.debian.org&#x2F;debian-cd&#x2F;current&#x2F;i386&#x2F;iso-dvd&#x2F;debian-9.6.0-i386-DVD-2.iso</span><br><span class="line">���ӣ�https:&#x2F;&#x2F;cdimage.debian.org&#x2F;debian-cd&#x2F;current&#x2F;i386&#x2F;iso-dvd&#x2F;debian-9.6.0-i386-DVD-3.iso</span><br><span class="line"> </span><br><span class="line"># ������ʱ163��վ�����ľ��񣬶����Ƿֳɲ�ͬ������汾�����صģ�����������ڣ�����ֱ��ѡ������һ������������ء�</span><br><span class="line"># ���ȿ�������һ��Debian�ĸ�������  cinnamon&#x2F;gnome(����)&#x2F;kde(����)&#x2F;lxde&#x2F;mate&#x2F;xfce</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-cinnamon.iso    ���ص�ַ</span><br><span class="line">���ӣ�http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-cinnamon.iso</span><br><span class="line"></span><br><span class="line"># debian-live-9.6.0-i386-gnome.iso     ���ص�ַ</span><br><span class="line">���ӣ�http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-gnome.iso</span><br><span class="line"></span><br><span class="line"># debian-live-9.6.0-i386-kde.iso  ���ص�ַ</span><br><span class="line">���ӣ�http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-kde.iso</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-lxde.iso    ���ص�ַ</span><br><span class="line">���ӣ�http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-lxde.iso</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-mate.iso     ���ص�ַ</span><br><span class="line">����: http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-mate.iso</span><br><span class="line"> </span><br><span class="line"># debian-live-9.6.0-i386-xfce.iso     ���ص�ַ</span><br><span class="line">���ӣ�http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-cd&#x2F;9.6.0-live&#x2F;i386&#x2F;iso-hybrid&#x2F;debian-live-9.6.0-i386-xfce.iso </span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;һЩ��Դ������վ����&quot;&gt;&lt;a href=&quot;#һЩ��Դ������վ����&quot; class=&quot;headerlink&quot; title=&quot;һЩ��Դ������վ����&quot;&gt;&lt;/a&gt;һЩ��Դ������վ����&lt;/h2&gt;&lt;h4 id=&quot;��Դ��վ����&quot;&gt;&lt;a href=&quot;#��Դ��վ����&quot; class=&quot;headerlink&quot; title=&quot;��Դ��վ����&quot;&gt;&lt;/a&gt;��Դ��վ����&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;�Ѻ���Դ����վ��&lt;a href=&quot;http://mirrors.sohu.com/&quot;&gt;http://mirrors.sohu.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;���׿�Դ����վ��&lt;a href=&quot;http://mirrors.163.com/&quot;&gt;http://mirrors.163.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;��Դ�й���&lt;a href=&quot;http://mirrors.oschina.net/&quot;&gt;http://mirrors.oschina.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;�׶����߿Ƽ��ɷ����޹�˾��&lt;a href=&quot;http://mirrors.yun-idc.com/&quot;&gt;http://mirrors.yun-idc.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;�����ƿ�Դ����&lt;a href=&quot;http://mirrors.aliyun.com/&quot;&gt;http://mirrors.aliyun.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LUPA��&lt;a href=&quot;http://mirror.lupaworld.com/&quot;&gt;http://mirror.lupaworld.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;���ݱ��ؿ�ķ�����������޹�˾(ԭcn99����&lt;a href=&quot;http://centos.bitcomm.cn/&quot;&gt;http://centos.bitcomm.cn/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="����ϵͳ" scheme="http://CherryYang05.github.io/categories/%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%CF%B5%CD%B3/"/>
    
    
      <category term="Linux" scheme="http://CherryYang05.github.io/tags/Linux/"/>
    
      <category term="��Դ����" scheme="http://CherryYang05.github.io/tags/%EF%BF%BD%EF%BF%BD%D4%B4%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD/"/>
    
      <category term="ϵͳ" scheme="http://CherryYang05.github.io/tags/%CF%B5%CD%B3/"/>
    
  </entry>
  
  <entry>
    <title>BAT批处理文件的使用（二）</title>
    <link href="http://cherryyang05.github.io/2020/05/09/BAT%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://cherryyang05.github.io/2020/05/09/BAT%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-05-09T10:44:22.000Z</published>
    <updated>2020-05-09T10:46:31.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等"><a href="#BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等" class="headerlink" title="BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等"></a>BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等</h2><p>前两天在使用 VSCode 的时候，看到之前那么多 cpp 编译产生的 exe 可执行文件，于是心生一个念头，我要把它们全部删掉，但是又不想一个个地删，便想到了利用 <code>bat</code> 脚本批量删除 exe 文件。于是在搜集了大量资料后，开始了编写。<br><a id="more"></a><br>首先就是一条简单的 <code>del</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del F:\Code\C++\*.exe</span><br></pre></td></tr></table></figure><br>但是发现只能删除掉 <code>C++</code> 那个文件夹根目录下的 exe 文件，然后发现，在后面加上 <code>/s</code>，表示在当前目录递归删除指定文件，就是还要进入子目录寻找文件。</p><blockquote><p>/a 根据百属性选择要删除的文件<br>/f 强制删除只读度文件<br>/s 从所有子目录删除指定文件<br>/q 安静模式。删除全局通配符时，不要求确知</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del F:\Code\C++\*.exe /s</span><br></pre></td></tr></table></figure><p>运行之后，哗啦啦，全删掉了(在其他盘里测试一下)：<br><img src="https://img-blog.csdnimg.cn/20200509172606608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>本来其实这样就可以了，把这个批处理脚本放到 C++ 文件夹根目录就行了，但是如果多次执行的时候，本来已经没有 exe 文件了，还要执行，就会提示 <code>找不到 G:\test\*.exe</code>，对于强迫症的我当然不能忍受起码提示一个 <code>exe文件已经删完啦</code> 之类的。要这样写势必要进行条件判断，然后，又去找了很多资料。<br>一开始搜到一个 <code>errorlevel</code> 的系统变量，会判断你当前这条语句是否执行，如果成功执行该变量的值为 <code>0</code>， 否则是 <code>1-255</code> 之间的某一个值，这里的值主要是根据语句未能成功执行的原因（其实就是跟中断类型差不多）来决定的，一般是 <code>1</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line">if ERRORLEVEL 1 goto fail</span><br><span class="line">if ERRORLEVEL 0 goto success</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del F:\Code\C++\*.exe /s</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br>运行后发现了中文乱码，于是改一下编码为 <code>ANSI</code><img src="https://img-blog.csdnimg.cn/20200509174008621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后再次执行，发现不管 <code>exe</code> 文件是否被删掉，都会执行 <code>success</code> 标号的语句，说明 <code>del</code> 语句都被执行了，只是找不到文件而已。<br><img src="https://img-blog.csdnimg.cn/20200509174405846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种方法不行那就试试其他方法，用 <code>if exist</code> 条件判断应该可以吧<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line">::if ERRORLEVEL 1 goto fail</span><br><span class="line">::if ERRORLEVEL 0 goto success</span><br><span class="line">if exist F:\Code\C++\*.exe (goto success) else (goto fail)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del F:\Code\C++\*.exe /s</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br>这里的 <code>::</code>是注释，当然注释还有其他写法</p><blockquote><p>1、:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）<br>    2、rem 注释内容（不能出现重定向符号和管道符号）<br>    3、echo 注释内容（不能出现重定向符号和管道符号）〉nul<br>    4、if not exist nul 注释内容（不能出现重定向符号和管道符号）<br>    5、:注释内容（注释文本不能与已有标签重名）<br>    6、%注释内容%（可以用作行间注释，不能出现重定向符号和管道符号）<br>    7、goto 标签 注释内容（可以用作说明goto的条件和执行内容）<br>    8、:标签 注释内容（可以用作标签下方段的执行内容</p></blockquote><p>完美执行。<br>然后在之后的其他测试中，若 <code>C++</code> 根目录下没有 <code>exe</code> 文件，而在其子文件夹下有 <code>exe</code> 文件的话，就出问题了，因为 <code>if exist</code> 那行语句只是判断当前文件夹根目录下是否存在 <code>exe</code> 文件。那该怎么办呢？<br>应该要对 <code>C++</code> 根目录进行递归查找，便是 <code>for</code> 语句：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cls</span><br><span class="line">set PATH=F:\Code\C++\</span><br><span class="line">set FILE=*.exe</span><br><span class="line">set cnt=0</span><br><span class="line">for /R %PATH% %%s in (%FILE%) do (</span><br><span class="line">::echo %%s</span><br><span class="line">set /a cnt=%cnt%+1</span><br><span class="line">)</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">if %cnt% EQU 0 (goto fail) else (goto success)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del *.exe /s</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">goto done</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br><code>for</code> 循环后面的 <code>/R</code> 便是对当前文件夹进行递归查找，若存在后缀名为 <code>.exe</code> 文件，便把计数值+1.然后运行，又出错了。。。<br>cnt的值始终为1，这又是为什么呢？<br>又查了许多资料，发现 批处理语法中还有叫什么 <code>变量延迟</code> 的语法，具体就是 <strong>当我们准备执行一条命令的时候，命令解释器会先将命令读取，如果命令中有环境变量，那么就会将变量的值先读取来出，然后在运行这条命令</strong>，如：<code>echo %cnt%</code>，当我们执行这条命令的时候，命令解释器会先读出 <code>%cnt%</code> 的值，然后执行echo，得到的结果是屏幕上显示出 <code>cnt的值</code>。但是，有的时候，我们在执行一条命令的时候，命令解释器将环境变量的值读出来以后，我们的环境变量的值发生了改变，这时个再执行命令就是使用的变量改变前的值，这就不是我们想要的结果了。<br>也就是，当 <code>for</code> 语句执行时，命令解释器首先把它变成<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /R %s in (*.exe) do (set /a cnt=0+1 )</span><br></pre></td></tr></table></figure><br>因此在这个循环里面 <code>cnt</code> 就全是0了，这里我们就需要用到 <code>变量延迟</code> 了，设置 <code>setlocal enabledelayedexpansion</code>，然后将需要使用变量延迟的变量两边用 <code>!</code> 表示，即 <code>set /a cnt=!cnt!+1</code>.<br>关闭变量延迟的话就是 <code>setlocal disabledelayedexpansion</code>.<br>全部修改完了 <code>bat</code> 程序如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cls</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">set PATH=F:\Code\C++\</span><br><span class="line">set FILE=*.exe</span><br><span class="line">set cnt=0</span><br><span class="line">for /R %PATH% %%s in (%FILE%) do (</span><br><span class="line">::echo %%s</span><br><span class="line">set /a cnt=!cnt!+1</span><br><span class="line">)</span><br><span class="line">if %cnt% EQU 0 (goto fail) else (goto success)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del %PATH%%FILE% /s</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">goto done</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br><span class="line">endlocal</span><br></pre></td></tr></table></figure><p>大功告成！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等&quot;&gt;&lt;a href=&quot;#BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等&quot; class=&quot;headerlink&quot; title=&quot;BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等&quot;&gt;&lt;/a&gt;BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等&lt;/h2&gt;&lt;p&gt;前两天在使用 VSCode 的时候，看到之前那么多 cpp 编译产生的 exe 可执行文件，于是心生一个念头，我要把它们全部删掉，但是又不想一个个地删，便想到了利用 &lt;code&gt;bat&lt;/code&gt; 脚本批量删除 exe 文件。于是在搜集了大量资料后，开始了编写。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="BAT批处理" scheme="http://CherryYang05.github.io/categories/BAT%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
    
      <category term="BAT" scheme="http://CherryYang05.github.io/tags/BAT/"/>
    
      <category term="批处理" scheme="http://CherryYang05.github.io/tags/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
      <category term="脚本" scheme="http://CherryYang05.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>密码学（二）：古典密码之维吉尼亚密码的破解</title>
    <link href="http://cherryyang05.github.io/2020/05/06/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E7%9A%84%E7%A0%B4%E8%A7%A3/"/>
    <id>http://cherryyang05.github.io/2020/05/06/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E7%9A%84%E7%A0%B4%E8%A7%A3/</id>
    <published>2020-05-06T09:08:39.000Z</published>
    <updated>2020-05-06T11:41:27.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="维吉尼亚密码的破解"><a href="#维吉尼亚密码的破解" class="headerlink" title="维吉尼亚密码的破解"></a>维吉尼亚密码的破解</h2><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>&emsp;&emsp;上一章我们介绍了维吉尼亚密码的原理，是通过移位替换的加密方法进行加密，但是因为概率论的出现这种简单的移位或替换就容易破解了，其原理很简单，英文中字母出现的频率是不一样的。比如字母 <strong>e</strong> 是出现频率最高的，占<strong>12.7%</strong>；其次是<strong>t</strong>，<strong>9.1%</strong>；然后是<strong>a</strong>，<strong>o</strong>，<strong>i</strong>，<strong>n</strong>等，最少的是<strong>z</strong>，只占<strong>0.1%</strong>。<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20200216150747368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="字母出现概率"></p><p><a id="具体概率表">具体概率表</a></p><p><img src="https://img-blog.csdnimg.cn/20200216161337882.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_26,color_FFFFFF,t_70" width="450" height="500" alt="概率表" style="margin-left:50px"></p><p>除了英语，其他语言也有相关统计（<a href="https://www.cnblogs.com/inverseEntropy/p/10151176.html">图片来源</a>）<br><img src="https://img-blog.csdnimg.cn/20200216150833315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="多种语言的字母出现频率"></p><h3 id="二、一般破解的方法"><a href="#二、一般破解的方法" class="headerlink" title="二、一般破解的方法"></a>二、一般破解的方法</h3><h4 id="1-穷举密钥搜索"><a href="#1-穷举密钥搜索" class="headerlink" title="1. 穷举密钥搜索"></a>1. 穷举密钥搜索</h4><p>&emsp;&emsp;只适用于与小的密钥空间，而像维吉尼亚密码的 $Z^n_{26}$ 是 26 的 n 次方的空间，当 n 很大时，计算量是相当大的。</p><h4 id="2-频率统计"><a href="#2-频率统计" class="headerlink" title="2. 频率统计"></a>2. 频率统计</h4><h5 id="单表代换"><a href="#单表代换" class="headerlink" title="单表代换"></a>单表代换</h5><p><strong>移位密码：</strong> 相同的明文字母总是对应相同的密文字母，因此，尽管字母的外形改变了，他出现的概率还是不变的，只要根据足够多的样例来进行统计，最终密文字母的出现概率总是近似于明文字母的出现概率，并且与之一一对应。</p><h5 id="多表代换"><a href="#多表代换" class="headerlink" title="多表代换"></a>多表代换</h5><p><strong>维吉尼亚密码：</strong> 相同的明文字母可能对应不同的密文字母，这里讲的维吉尼亚密码的破解也是根据字母出现的频率的蛛丝马迹进行破解。</p><h3 id="三、维吉尼亚密码的破解"><a href="#三、维吉尼亚密码的破解" class="headerlink" title="三、维吉尼亚密码的破解"></a>三、维吉尼亚密码的破解</h3><h4 id="1-确定密钥长度"><a href="#1-确定密钥长度" class="headerlink" title="1. 确定密钥长度"></a>1. 确定密钥长度</h4><h5 id="方法一：Kasiski测试法"><a href="#方法一：Kasiski测试法" class="headerlink" title="方法一：Kasiski测试法"></a>方法一：Kasiski测试法</h5><p><strong>原理：密文中出现两个相同字母组，它们所对应的明文字母相同的可能性很大，这样的两个密文字母组之间的距离可能为密钥长度的整数倍。</strong><br><img src="https://img-blog.csdnimg.cn/2020021617084725.jpg" alt="在这里插入图片描述"><br>&emsp;&emsp;尽管在维吉尼亚密码中相同的明文可能对应不同的密文，但是若连续出现相同的密文，那么用同样的密钥加密的概率会大大增加。这里密文 $ZB$ 都是用 $HI$ 加密，计算两者之间的距离为 $5$，因此可推断出来密钥长度为 $5.$</p><h5 id="方法二：重合指数法"><a href="#方法二：重合指数法" class="headerlink" title="方法二：重合指数法"></a>方法二：重合指数法</h5><p><strong>原理：自然语言（以英语为例）的重合指数约为 0.065，而且单标代换不会改变该值。</strong><br><strong>重合指数定义：</strong></p><p>设 <script type="math/tex">x=x_1x_2...x_n</script> 是含有 $n$ 个字母的串，则在 $x$ 中随机选择两个元素且这两个元素相同的概率为：</p><p>定义：$f_i$ 为 26 个字母中第 $i$ 个字母在 $x$ 中出现的次数</p><p>[例如：$x=AAZZZ,n=5,f<em>0=2,f</em>{25}=3$，第一次取出 A 的概率为 $\frac {f_0} {n}$，第二次再取出 A 的概率为 $\frac {f_0} {n} * \frac {f_0-1} {n-1}$]</p><p>当我们把 26 个字母的概率全部相加，得到的总的概率就是<strong>重合指数</strong>：</p><script type="math/tex; mode=display">I_c(x)={\frac {\displaystyle\sum_{i=0}^{25}f_i(f_i-1)} {n(n-1)} }</script><p>当计算的数量很大时，我们将 $n(n-1)$ 近似为 $n^2$，将 $f_i(f_i-1)$ 近似为 $f_i^2$</p><p>因此</p><script type="math/tex; mode=display">I_c(x) \approx \displaystyle\sum_{i=0}^{25} {p_i^2} \approx0.065</script><p>这里的 $p_i$ 表示第 $i$ 个字母在英语语言中出现的概率，就是在<a href="#具体概率表">引言</a>中列出的数值。<br>这个数值非常重要。</p><p><strong>注意：在单表代换中，不会改变该值，也就是用相同密钥字加密应服从相同的重合指数。</strong></p><h5 id="猜测密钥长度"><a href="#猜测密钥长度" class="headerlink" title="猜测密钥长度"></a>猜测密钥长度</h5><p>&emsp;&emsp;假设密钥长度为 $d$，提取相同密钥字加密的密文，测试其重合指数。<br>&emsp;&emsp;如果猜测正确，则重合指数接近 $0.065$，否则字符串表现得更加随机一般在 $0.038(1/26) \thicksim 0.065$ 之间。<br><img src="https://img-blog.csdnimg.cn/20200216184236771.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="猜测密钥长度"><br>&emsp;&emsp;在这里，我们先猜测密钥长度为 5，然后将密文按照 5 进行分组，分别提取出用密钥 $k_1,k_2,k_3,k_4,k_5$ 加密的密文，组成集合 $C_1,C_2,C_3,C_4,C_5$，这样就把多表代换转化成了单表代换。<br>这里 $C_1={Z,P,L,W,Z},C_2={P,A,Z,Z,N},C_3={D,Z,B,B,M},C_4={X,H,H,K},C_5={V,S,I,M}$</p><p>以一个例子为例：<br><img src="https://img-blog.csdnimg.cn/20200216214722472.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;$CHR$ 这三个字符出现频率较高，因此我们将其位置记录下来，测算他们之间的距离，并取最大公因数 5，猜测 5 便是密钥长度。这很有可能是相同的明文被相同的密文加密了。其实很容易猜到，这很可能是英语当中的定冠词 <strong>the</strong>.</p><p>我们在用重合指数法进行测试，分别测试 $d=1,2,3,4,5$ （过程略）</p><div class="table-container"><table><thead><tr><th>$d$</th><th>重合指数</th></tr></thead><tbody><tr><td>$1$</td><td>$[0.045]$</td></tr><tr><td>$2$</td><td>$[0.046,0.041]$</td></tr><tr><td>$3$</td><td>$[0.043,0050,0.047]$</td></tr><tr><td>$4$</td><td>$[0.042,0.039,0.046,0.040]$</td></tr><tr><td>$5$</td><td>$[0.063,0.068,0.069,0.061,0.072]$</td></tr></tbody></table></div><p>&emsp;&emsp;观察发现，只有当 $d=5$ 的时候，重合指数接近 $0.065$，因此刚刚的猜测 $d=5$ 是正确的，这时通过穷举密钥的复杂度为 $26^5$，但是仍然比较大。</p><h4 id="2-确定密钥字相对位移"><a href="#2-确定密钥字相对位移" class="headerlink" title="2. 确定密钥字相对位移"></a>2. 确定密钥字相对位移</h4><p>密钥字的相对位移实际上就是确定密钥之间的相互关系。<br>这里引入一个定义：</p><p><strong>重合互指数:</strong><br>&emsp;&emsp;设 $x=x<em>1,x_2,…,x_n,y=y_1,y_2,…,y</em>{n’}$，分别为长度为 $n$ 和 $n’$ 的串，其重合互指数为从 $x$ 和 $y$ 中分别随机选出一个元素且两个元素相同的概率。</p><p>计算方法和刚刚的计算方法类似：</p><script type="math/tex; mode=display">MI_c(x,y)=\frac{\displaystyle\sum_{i=0}^{25}f_if'_i}{nn'}</script><p>具体不再阐述。</p><p>&emsp;&emsp;考虑不同密钥字加密后密文串的重合互指数，设密钥字为 $k=k<em>1k_2…k_d$，$C_i$ 中的一个字母与 $C_j$ 中的一个字母都是 $A$ 的概率为 $p</em>{0-k<em>i}p</em>{0-k_j}$.</p><p>其中 $p_{0-k_i}$ 为密文 $A$ 所对应明文字母的出现概率。同理可以计算 $B,C,D,…,Z$，因此：</p><script type="math/tex; mode=display">MI_c(C_i,C_j) \approx \displaystyle\sum_{l=0}^{25}p_{l-k_i}p_{l-k_j}=\displaystyle\sum_{l=0}^{25}p_lp_{l+k_i-k_j}=\displaystyle\sum_{l=0}^{25}p_{l-k_i+k_j}p_l</script><p>这里的下标是需要对 26 取模的，可以观察到：$Mi_c$ 取决于相对位移 $k_i-k_j$.</p><p>移位表如下：<br><img src="https://img-blog.csdnimg.cn/20200216224709354.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="500"><br>观察这里当相对距离为0时，重合互指数为 $0.065$，在之前提到的自然语言的重合互指数也是 $0.065$，这并不是巧合。当相对位移位 0 时，其实就是 $C_1,C_2$ 的集合是用同一种密文加密得到，这也就是单表代换这样，并不会改变重合指数。</p><p>这里其实并不需要列举从 0 到 25 的所有值。</p><h5 id="猜测不同密钥字的相对位移s（猜测范围0-25）"><a href="#猜测不同密钥字的相对位移s（猜测范围0-25）" class="headerlink" title="猜测不同密钥字的相对位移s（猜测范围0~25）"></a>猜测不同密钥字的相对位移s（猜测范围0~25）</h5><script type="math/tex; mode=display">MI_c(C_i,C_j)=\frac{\displaystyle\sum_{t=0}^{25}f_{i,t}f_{j,t-s} } {n_in_j}</script><p>&emsp;&emsp;这里 $n<em>i$ 是指集合 $C_i$ 中字符个数，这里 $n_j$ 是指集合 $C_j$ 中字符个数，$f</em>{i,t}$ 表示在集合 $C<em>i$ 中，$t$ 这个密文字符出现的次数，$f</em>{j,t-s}$ 表示在集合 $C_j$ 中，$t-s$ 这个密文字符出现的次数。</p><p>&emsp;&emsp;如果猜对 $s$，那么 $MI_c$ 应该接近 $0.065$，这意味着找到了<strong>不同密钥字加密的相同的明文字母</strong>，这也就找到了密钥字之间的相对位移，也就转化成了单表代换。<br>这里用 $m$ 表示明文字母，$c,c’$ 分别表示 $C_i,C_j$ 中 $m$ 对应的密文字母，那么：</p><script type="math/tex; mode=display">m=c-k_i \pmod{26} \\ m=c'-k_j \pmod{26}</script><p>&emsp;&emsp;实际上，在维吉尼亚密码中，并没有很好的隐藏密钥和密文之间的相互关系，密钥之间的相互差距会体现在密文之间的相互关系。</p><p>&emsp;&emsp;我们计算上面例子中的集合 $C_1,C_2,C_3,C_4,C_5$ 两两之间的重合互指数：</p><p><img src="https://img-blog.csdnimg.cn/20200216231804835.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="550"></p><p>&emsp;&emsp;这里的 $i,j$ 表示当取到不同集合的时候，后面的值表示当猜测的相对位移 $s$ 取不同值的时候重合互指数的结果。</p><p>&emsp;&emsp;我们观察结果，当 $i=1,j=2,s=9$ 时，重合互指数达到了 $0.068$，因此可以得到 $k_1-k_2=9$.<br>&emsp;&emsp;但是当 $i=1,j=3;i=1,j=4$ 时，没有合适的相对位移，那么我们先暂时跳过，观察其他结果，发现当 $i=1,j=5,s=16$ 时，重合互指数达到 $0.070$，$i=2,j=3,s=13$ 的时候，重合互指数达到了 $0.067$.<br><img src="https://img-blog.csdnimg.cn/2020021623254417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="550"><br>我们列举完剩下的结果，得到：</p><script type="math/tex; mode=display">k_1-k_2=9 \\ k_1-k_5=16 \\ k_2-k_3=13 \\ k_2-k_5=7 \\ k_3-k_5=20 \\ k_4-k_5=11</script><h4 id="3-穷举搜索密钥字"><a href="#3-穷举搜索密钥字" class="headerlink" title="3. 穷举搜索密钥字"></a>3. 穷举搜索密钥字</h4><p>&emsp;&emsp;根据上述的结果，在确定密钥字之间关系式的基础上，只要穷举 $26$ 中可能性就可以了。因为当猜测 $k_1$ 的时候， $k_2$ 也就确定下来了，以此类推，剩下的几个密钥也就确定下来了，只要从 $A-Z$ 进行穷举即可。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>&emsp;&emsp;一个好的密码加密方案（或者说是算法），应该要很好的隐藏密钥和密文之间的联系，通过更复杂的算法或者在更大的密钥空间中，可以有效避免穷举搜索破解。如何设计加密算法以及如何选择合适的密钥空间，将在今后继续学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;维吉尼亚密码的破解&quot;&gt;&lt;a href=&quot;#维吉尼亚密码的破解&quot; class=&quot;headerlink&quot; title=&quot;维吉尼亚密码的破解&quot;&gt;&lt;/a&gt;维吉尼亚密码的破解&lt;/h2&gt;&lt;h3 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;上一章我们介绍了维吉尼亚密码的原理，是通过移位替换的加密方法进行加密，但是因为概率论的出现这种简单的移位或替换就容易破解了，其原理很简单，英文中字母出现的频率是不一样的。比如字母 &lt;strong&gt;e&lt;/strong&gt; 是出现频率最高的，占&lt;strong&gt;12.7%&lt;/strong&gt;；其次是&lt;strong&gt;t&lt;/strong&gt;，&lt;strong&gt;9.1%&lt;/strong&gt;；然后是&lt;strong&gt;a&lt;/strong&gt;，&lt;strong&gt;o&lt;/strong&gt;，&lt;strong&gt;i&lt;/strong&gt;，&lt;strong&gt;n&lt;/strong&gt;等，最少的是&lt;strong&gt;z&lt;/strong&gt;，只占&lt;strong&gt;0.1%&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="密码学" scheme="http://CherryYang05.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="http://CherryYang05.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="古典密码" scheme="http://CherryYang05.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    
      <category term="维吉尼亚密码" scheme="http://CherryYang05.github.io/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>密码学（一）：古典密码之维吉尼亚密码介绍</title>
    <link href="http://cherryyang05.github.io/2020/05/06/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E4%BB%8B%E7%BB%8D/"/>
    <id>http://cherryyang05.github.io/2020/05/06/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-05-06T08:55:26.000Z</published>
    <updated>2020-05-06T09:06:59.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="维吉尼亚（Vigenere-Cipher）密码原理介绍"><a href="#维吉尼亚（Vigenere-Cipher）密码原理介绍" class="headerlink" title="维吉尼亚（Vigenère Cipher）密码原理介绍"></a>维吉尼亚（Vigenère Cipher）密码原理介绍</h2><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><blockquote><p>&emsp;&emsp;维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。<br>&emsp;&emsp;维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。<br>&emsp;&emsp;维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”（法语：le chiffre indéchiffrable）。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。<br>来源：<a href="https://baike.baidu.com/item/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/4905472?fr=aladdin">百度百科</a><br><img src="https://img-blog.csdnimg.cn/20200216154546299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a id="more"></a></p><h3 id="二、古典密码"><a href="#二、古典密码" class="headerlink" title="二、古典密码"></a>二、古典密码</h3><h4 id="1-移位密码"><a href="#1-移位密码" class="headerlink" title="1. 移位密码"></a>1. 移位密码</h4><p>我们首先引入符号表示：<br>$P$：明文空间，所有可能的明文组成的有限集<br>$C$：密文空间，所有可能的密文组成的有限集<br>$K$：密钥空间，所有可能的密钥 $k$ 组成的有限集<br>$Enc$：加密算法<br>&emsp;&emsp;$Enc_k(m)=c$ 加密算法$Enc$以密钥$k$、明文$m$为输入，输出密文$c$<br>$Dec$：加密算法<br>&emsp;&emsp;$Dec_k(c)=m$ 解密算法$Dec$以密钥$k$、密文$c$为输入，输出明文$m$<br>算法正确性：对每个明文 $m\in P$ 以及秘钥 $k\in K$ 都有 $Dec_k(Enc_k(m))=m$</p></blockquote><p>其中最典型的移位密码就是凯撒密码，凯撒密码是通过移位替换的方法，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。</p><script type="math/tex; mode=display">令P=C=K=Z_{26}=\{ 0,1,2,3,...,25 \} \\随机选择 K \in Z_{26} 作为密钥 \\Enc_k(m)=m+k \pmod {26} \\Dec_k(c)=c-k\pmod{26}</script><p>其中 $Z_{26}$ 是26个英文字母组成的集合空间。<br>例如，当偏移量$k$是3的时候，所有的字母A将被替换成D，B变成E … Z变成C，以此类推。</p><h4 id="2-维吉尼亚密码"><a href="#2-维吉尼亚密码" class="headerlink" title="2.维吉尼亚密码"></a>2.维吉尼亚密码</h4><p>维吉尼亚密码便是移位密码的推广</p><script type="math/tex; mode=display">P=C=K=Z_{26}^n\\随机选择密钥k=(k_1,k_2,..,k_n) \in Z_{26}^n \\Enc_k(m_1,m_2,...,m_n)=(m_1+k_1,m_2+k_2,...,m_n+k_n) \\Dec_k(c_1,c_2,...,c_n)=(c_1-k_1,c_2-k_2,...,c_n-k_n)</script><p>实际上就是每个明文加上对应的密钥字。<br>举例如下：若密钥为 $CIPHER$，即 $k=(2,8,15,7,4,17)$<br><img src="https://img-blog.csdnimg.cn/20200216154923425.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>明文是以下字符串：</p><p>$THISCRYPTOSYSTEMISNOTSECURE$</p><p>我们根据字母表将字符串翻译成数字：</p><p>$(19,7,8,18,2,17,24,15,19,14,18,24,18,19,4,12,8,18,13,14,19,18,4,2,20,17,4)$</p><p>然后将其按照密钥个数进行分组，分别与集合 $K$ 相加，得到密钥：</p><p>$(21,15,23,25,6,8,0,23,8,21,22,15,20,1,19,19,12,9,15,22,8,25,8,19,22,25,19)$</p><p>因此密文为：</p><p>$VPXZGIAXIVWPUBTTMJPWIZITWZT$</p><h4 id="3-二维表形式"><a href="#3-二维表形式" class="headerlink" title="3. 二维表形式"></a>3. 二维表形式</h4><p>我们观察到，若密钥为1的话，A将会变成B，若密钥为2的话，A将会变成C，实际上就是字母表整体往左边移动了一个字母和两个字母的距离，我们把移动的26种情况整理下来，变成了一张二维表。<br>其中棕色的行表示明文，橙色的列表示密钥。<br>若密钥为3，实际上对应的字母为C，那么就到C的那一行，可以观察到，A对应的是C，以此类推。因此若想找明文A对应密钥为C的密文，只要找他们的交点即可。以上述例子为例，$THIS$ 的密钥为$(2,8,5,17)$，对应的字母为 $CIPH$，找到 $T$ 和 $C$的交点 $V$，$H$ 和 $I$ 的交点 $P$，$I$ 和 $P$ 的焦点 $X$，$S$ 和 $H$ 的交点 $Z$.因此其密文为 $VPXZ.$<br><img src="https://img-blog.csdnimg.cn/20200216150222284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="维吉尼亚密码二维表"><br>普通的移位密码是通过相同的移位来加密，若明文中有两个相同的字母，例如 $HAPPY$ 的$P$，加密过后仍然会有两个相同的字母，若样本多了之后，就可以根据一些单词的特征进行判断推理进行解密，因此普通的移位加密并不是一种好的加密方法。维吉尼亚密码就可以很好的解决这样的问题。</p><p>下一章将介绍维吉尼亚密码的解密。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;维吉尼亚（Vigenere-Cipher）密码原理介绍&quot;&gt;&lt;a href=&quot;#维吉尼亚（Vigenere-Cipher）密码原理介绍&quot; class=&quot;headerlink&quot; title=&quot;维吉尼亚（Vigenère Cipher）密码原理介绍&quot;&gt;&lt;/a&gt;维吉尼亚（Vigenère Cipher）密码原理介绍&lt;/h2&gt;&lt;h3 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。&lt;br&gt;&amp;emsp;&amp;emsp;维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。&lt;br&gt;&amp;emsp;&amp;emsp;维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”（法语：le chiffre indéchiffrable）。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。&lt;br&gt;来源：&lt;a href=&quot;https://baike.baidu.com/item/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/4905472?fr=aladdin&quot;&gt;百度百科&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200216154546299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="密码学" scheme="http://CherryYang05.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="http://CherryYang05.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="古典密码" scheme="http://CherryYang05.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    
      <category term="维吉尼亚密码" scheme="http://CherryYang05.github.io/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://cherryyang05.github.io/2020/05/04/hello-world/"/>
    <id>http://cherryyang05.github.io/2020/05/04/hello-world/</id>
    <published>2020-05-04T04:10:51.326Z</published>
    <updated>2021-02-16T13:54:18.314Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo博客" scheme="http://CherryYang05.github.io/categories/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Test" scheme="http://CherryYang05.github.io/tags/Test/"/>
    
      <category term="demo" scheme="http://CherryYang05.github.io/tags/demo/"/>
    
  </entry>
  
</feed>
